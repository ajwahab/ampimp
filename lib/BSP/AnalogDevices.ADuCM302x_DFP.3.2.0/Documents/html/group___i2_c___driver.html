<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ADuCM302x Device Drivers API Reference Manual: I2C Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ADuCM302x Device Drivers API Reference Manual
   &#160;<span id="projectnumber">Release 3.1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___i2_c___driver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C Driver</div>  </div>
</div><!--header-->
<div class="contents">

<p>Inter-Integrated Circuit (I2C) Driver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___i2_c___driver___config"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___driver___config.html">Static Configuration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d_i___i2_c___t_r_a_n_s_a_c_t_i_o_n.html">ADI_I2C_TRANSACTION</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga46f6ea4ccd873a8412631c9a01e38a06"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___driver.html#ga46f6ea4ccd873a8412631c9a01e38a06">ADI_I2C_MEMORY_SIZE</a>&#160;&#160;&#160;(44u + ADI_SEM_SIZE)</td></tr>
<tr class="separator:ga46f6ea4ccd873a8412631c9a01e38a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefdd6b26c84e472a90d51cfe5bb347c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___driver.html#gaefdd6b26c84e472a90d51cfe5bb347c9">ADI_I2C_MAX_RATE</a>&#160;&#160;&#160;(400000u)</td></tr>
<tr class="separator:gaefdd6b26c84e472a90d51cfe5bb347c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga34a6d8c01e422cb46c0999ad1ec624be"><td class="memItemLeft" align="right" valign="top">typedef struct __ADI_I2C_DEV_DATA_TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a></td></tr>
<tr class="separator:ga34a6d8c01e422cb46c0999ad1ec624be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga96b1078c3d1494d305c9b7e4103e4caf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaa9d1b5a54050b4445fbf155b9eb337d6">ADI_I2C_SUCCESS</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa4d2fbe391bb9610de1af5b067b4879a0">ADI_I2C_BAD_BITRATE</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa4c7159a2670ef615e7e9860aba9ae7de">ADI_I2C_BAD_DEVICE_HANDLE</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa00af783932ab386f10452892575d0be4">ADI_I2C_BAD_DEVICE_NUMBER</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaba5ae0b4598a8476132724a7bb084679">ADI_I2C_BAD_SYS_CLOCK</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafae71f46e60ba8e66db584a49292bf45d3">ADI_I2C_DEVICE_IN_USE</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa46324c2be997bb540051c160aff78a34">ADI_I2C_DEVICE_NOT_OPEN</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa8f0f590fdccb7f4171ca21ed34da7cf8">ADI_I2C_FAILURE</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa6763c65d020ffb6136012e271430de94">ADI_I2C_HW_ERROR_DETECTED</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa58170da1dacc86327c2d09c51484cb7a">ADI_I2C_INSUFFICIENT_MEMORY</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafacec357b8230c26c2c1dfc4db34c7bce2">ADI_I2C_INVALID_PARAMETER</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa963cec75f2dfb386635f9478c1891d28">ADI_I2C_INVALID_SLAVE_ADDRESS</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaf5f5c30a31938a71f438b8efcde39340">ADI_I2C_INVALID_SUBMIT_API</a>, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafadd8a56fc50ccc323299866d8f2809279">ADI_I2C_SEMAPHORE_FAILED</a>
<br />
 }</td></tr>
<tr class="separator:ga96b1078c3d1494d305c9b7e4103e4caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f9b7f99a70885ddddd12a48f274f820"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___driver.html#ga3f9b7f99a70885ddddd12a48f274f820">ADI_I2C_HW_ERRORS</a> { <br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga3f9b7f99a70885ddddd12a48f274f820af3facc96a965fd4096f403fcc05d48be">ADI_I2C_HW_ERROR_NONE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga3f9b7f99a70885ddddd12a48f274f820a102f8ef230c4d5ec658d98b115e08ad2">ADI_I2C_HW_ERROR_NACK_ADDR</a> = 0x0001, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga3f9b7f99a70885ddddd12a48f274f820a8f84e914a7135399f1e10a1c9b1e75e3">ADI_I2C_HW_ERROR_NACK_DATA</a> = 0x0002, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga3f9b7f99a70885ddddd12a48f274f820ae62c179c01593380fabba5e6f70f2e95">ADI_I2C_HW_ERROR_ARBITRATION_LOST</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="group___i2_c___driver.html#gga3f9b7f99a70885ddddd12a48f274f820a3fa62b7541b4391d29335f19dca5e2d0">ADI_I2C_HW_ERROR_UNEXPECTED_ERROR</a> = 0x0008
<br />
 }</td></tr>
<tr class="separator:ga3f9b7f99a70885ddddd12a48f274f820"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga169717b204e91c7a5a0c3acb98fbf3aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___driver.html#ga169717b204e91c7a5a0c3acb98fbf3aa">adi_i2c_Open</a> (uint32_t const DeviceNum, void *const pMemory, uint32_t const MemorySize, <a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> *const phDevice)</td></tr>
<tr class="memdesc:ga169717b204e91c7a5a0c3acb98fbf3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize and allocate an I2C device for use in Master Mode.  <a href="#ga169717b204e91c7a5a0c3acb98fbf3aa">More...</a><br /></td></tr>
<tr class="separator:ga169717b204e91c7a5a0c3acb98fbf3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0afc18d59e87e826bccb210e6f559c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___driver.html#ga0afc18d59e87e826bccb210e6f559c5b">adi_i2c_Close</a> (<a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const hDevice)</td></tr>
<tr class="memdesc:ga0afc18d59e87e826bccb210e6f559c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninitialize and deallocate an I2C device.  <a href="#ga0afc18d59e87e826bccb210e6f559c5b">More...</a><br /></td></tr>
<tr class="separator:ga0afc18d59e87e826bccb210e6f559c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace0149b86e9f4bc42d8597c498428b9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___driver.html#gace0149b86e9f4bc42d8597c498428b9b">adi_i2c_ReadWrite</a> (<a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const hDevice, <a class="el" href="struct_a_d_i___i2_c___t_r_a_n_s_a_c_t_i_o_n.html">ADI_I2C_TRANSACTION</a> *const pTransaction, uint32_t *const pHwErrors)</td></tr>
<tr class="memdesc:gace0149b86e9f4bc42d8597c498428b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking I2C Master-Mode data read/write API.  <a href="#gace0149b86e9f4bc42d8597c498428b9b">More...</a><br /></td></tr>
<tr class="separator:gace0149b86e9f4bc42d8597c498428b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac898de0c211c2fccfc4f3760ac1c9eb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___driver.html#gac898de0c211c2fccfc4f3760ac1c9eb6">adi_i2c_SubmitBuffer</a> (<a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const hDevice, <a class="el" href="struct_a_d_i___i2_c___t_r_a_n_s_a_c_t_i_o_n.html">ADI_I2C_TRANSACTION</a> *const pTransaction)</td></tr>
<tr class="memdesc:gac898de0c211c2fccfc4f3760ac1c9eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-Blocking I2C Master-Mode data read or data write API.  <a href="#gac898de0c211c2fccfc4f3760ac1c9eb6">More...</a><br /></td></tr>
<tr class="separator:gac898de0c211c2fccfc4f3760ac1c9eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae849d5bb1db5df5f8c41fb5dd26fd335"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___driver.html#gae849d5bb1db5df5f8c41fb5dd26fd335">adi_i2c_IsBufferAvailable</a> (<a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const hDevice, bool *const pbCompletionState)</td></tr>
<tr class="memdesc:gae849d5bb1db5df5f8c41fb5dd26fd335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if a non-blocking I2C transfer is complete.  <a href="#gae849d5bb1db5df5f8c41fb5dd26fd335">More...</a><br /></td></tr>
<tr class="separator:gae849d5bb1db5df5f8c41fb5dd26fd335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga501a115731f2b6c61f9371fafb93b9cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___driver.html#ga501a115731f2b6c61f9371fafb93b9cc">adi_i2c_GetBuffer</a> (<a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const hDevice, uint32_t *const pHwErrors)</td></tr>
<tr class="memdesc:ga501a115731f2b6c61f9371fafb93b9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request ownership of a submitted buffer.  <a href="#ga501a115731f2b6c61f9371fafb93b9cc">More...</a><br /></td></tr>
<tr class="separator:ga501a115731f2b6c61f9371fafb93b9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a6635aef9a5eb9d31793cd5ae86f9b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___driver.html#ga5a6635aef9a5eb9d31793cd5ae86f9b2">adi_i2c_Reset</a> (<a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const hDevice)</td></tr>
<tr class="memdesc:ga5a6635aef9a5eb9d31793cd5ae86f9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset an I2C device and driver instance.  <a href="#ga5a6635aef9a5eb9d31793cd5ae86f9b2">More...</a><br /></td></tr>
<tr class="separator:ga5a6635aef9a5eb9d31793cd5ae86f9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabc8225a8d55e062cb0fde16e3a89adb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___driver.html#gaabc8225a8d55e062cb0fde16e3a89adb">adi_i2c_SetBitRate</a> (<a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const hDevice, uint32_t const requestedBitRate32)</td></tr>
<tr class="memdesc:gaabc8225a8d55e062cb0fde16e3a89adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the I2C serial bus speed.  <a href="#gaabc8225a8d55e062cb0fde16e3a89adb">More...</a><br /></td></tr>
<tr class="separator:gaabc8225a8d55e062cb0fde16e3a89adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dc8aa35c637be870fa7be6c258dbcc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___driver.html#ga4dc8aa35c637be870fa7be6c258dbcc2">adi_i2c_SetSlaveAddress</a> (<a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const hDevice, uint16_t const SlaveAddress)</td></tr>
<tr class="memdesc:ga4dc8aa35c637be870fa7be6c258dbcc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the I2C serial bus slave address.  <a href="#ga4dc8aa35c637be870fa7be6c258dbcc2">More...</a><br /></td></tr>
<tr class="separator:ga4dc8aa35c637be870fa7be6c258dbcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13b61881e8c5282ed94d5902c2901a17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___driver.html#ga13b61881e8c5282ed94d5902c2901a17">adi_i2c_IssueGeneralCall</a> (<a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const hDevice, uint8_t *const pData, uint8_t const nDataSize, uint32_t *const pHwErrors)</td></tr>
<tr class="memdesc:ga13b61881e8c5282ed94d5902c2901a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a General Call command to all slave devices on the I2C bus.  <a href="#ga13b61881e8c5282ed94d5902c2901a17">More...</a><br /></td></tr>
<tr class="separator:ga13b61881e8c5282ed94d5902c2901a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Inter-Integrated Circuit (I2C) Driver. </p>
<p>The I2C Master device driver manages the on-chip I2C hardware to control the external two-wire I2C Bus interface, allowing communication with multiple I2C slave devices through the I2C slave device addressing scheme. </p><dl class="section note"><dt>Note</dt><dd>The application must include <a class="el" href="adi__i2c_8h_source.html" title=": I2C device driver definitions ">drivers/i2c/adi_i2c.h</a> to use this driver </dd>
<dd>
This documentation presented here is API documentation only. The device drive user's guide, located in the Documents folder, explains how to use these APIs in an application. </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga46f6ea4ccd873a8412631c9a01e38a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46f6ea4ccd873a8412631c9a01e38a06">&#9670;&nbsp;</a></span>ADI_I2C_MEMORY_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADI_I2C_MEMORY_SIZE&#160;&#160;&#160;(44u + ADI_SEM_SIZE)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use macro "ADI_I2C_MEMORY_SIZE" to know how much memory to provide the i2c driver during the "adi_i2c_Open()" driver initialization call. This memory is used to store internal driver state data. Use map file to verify. </p>

<p class="definition">Definition at line <a class="el" href="adi__i2c_8h_source.html#l00134">134</a> of file <a class="el" href="adi__i2c_8h_source.html">adi_i2c.h</a>.</p>

</div>
</div>
<a id="gaefdd6b26c84e472a90d51cfe5bb347c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefdd6b26c84e472a90d51cfe5bb347c9">&#9670;&nbsp;</a></span>ADI_I2C_MAX_RATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADI_I2C_MAX_RATE&#160;&#160;&#160;(400000u)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum supported bitrate is "FAST" mode (400 kHz). </p>

<p class="definition">Definition at line <a class="el" href="adi__i2c_8h_source.html#l00210">210</a> of file <a class="el" href="adi__i2c_8h_source.html">adi_i2c.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="adi__i2c_8c_source.html#l00656">adi_i2c_SetBitRate()</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga34a6d8c01e422cb46c0999ad1ec624be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34a6d8c01e422cb46c0999ad1ec624be">&#9670;&nbsp;</a></span>ADI_I2C_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct __ADI_I2C_DEV_DATA_TYPE* <a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A device handle used in all API functions to identify the I2C device. </p>

<p class="definition">Definition at line <a class="el" href="adi__i2c_8h_source.html#l00127">127</a> of file <a class="el" href="adi__i2c_8h_source.html">adi_i2c.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga96b1078c3d1494d305c9b7e4103e4caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96b1078c3d1494d305c9b7e4103e4caf">&#9670;&nbsp;</a></span>ADI_I2C_RESULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C Device Error Codes. <a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaa9d1b5a54050b4445fbf155b9eb337d6">ADI_I2C_SUCCESS</a> is always zero The return value of all I2C APIs returning <a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a> should always be tested at the application level for success or failure. Specific I2C bus error conditions are returned as elements of <a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga96b1078c3d1494d305c9b7e4103e4cafaa9d1b5a54050b4445fbf155b9eb337d6"></a>ADI_I2C_SUCCESS&#160;</td><td class="fielddoc"><p>The API call succeeded. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga96b1078c3d1494d305c9b7e4103e4cafa4d2fbe391bb9610de1af5b067b4879a0"></a>ADI_I2C_BAD_BITRATE&#160;</td><td class="fielddoc"><p>The bit rate is invalid. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga96b1078c3d1494d305c9b7e4103e4cafa4c7159a2670ef615e7e9860aba9ae7de"></a>ADI_I2C_BAD_DEVICE_HANDLE&#160;</td><td class="fielddoc"><p>The device handle is invalid. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga96b1078c3d1494d305c9b7e4103e4cafa00af783932ab386f10452892575d0be4"></a>ADI_I2C_BAD_DEVICE_NUMBER&#160;</td><td class="fielddoc"><p>The device number is invalid. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga96b1078c3d1494d305c9b7e4103e4cafaba5ae0b4598a8476132724a7bb084679"></a>ADI_I2C_BAD_SYS_CLOCK&#160;</td><td class="fielddoc"><p>Unable to obtain system clock rate. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga96b1078c3d1494d305c9b7e4103e4cafae71f46e60ba8e66db584a49292bf45d3"></a>ADI_I2C_DEVICE_IN_USE&#160;</td><td class="fielddoc"><p>The device is in use. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga96b1078c3d1494d305c9b7e4103e4cafa46324c2be997bb540051c160aff78a34"></a>ADI_I2C_DEVICE_NOT_OPEN&#160;</td><td class="fielddoc"><p>The device is not open. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga96b1078c3d1494d305c9b7e4103e4cafa8f0f590fdccb7f4171ca21ed34da7cf8"></a>ADI_I2C_FAILURE&#160;</td><td class="fielddoc"><p>Generic API failure code. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga96b1078c3d1494d305c9b7e4103e4cafa6763c65d020ffb6136012e271430de94"></a>ADI_I2C_HW_ERROR_DETECTED&#160;</td><td class="fielddoc"><p>An I2C hardware error occurred. See <a class="el" href="group___i2_c___driver.html#ga3f9b7f99a70885ddddd12a48f274f820">ADI_I2C_HW_ERRORS</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga96b1078c3d1494d305c9b7e4103e4cafa58170da1dacc86327c2d09c51484cb7a"></a>ADI_I2C_INSUFFICIENT_MEMORY&#160;</td><td class="fielddoc"><p>The application supplied memory size is insufficient. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga96b1078c3d1494d305c9b7e4103e4cafacec357b8230c26c2c1dfc4db34c7bce2"></a>ADI_I2C_INVALID_PARAMETER&#160;</td><td class="fielddoc"><p>An invalid parameter is passed to the function. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga96b1078c3d1494d305c9b7e4103e4cafa963cec75f2dfb386635f9478c1891d28"></a>ADI_I2C_INVALID_SLAVE_ADDRESS&#160;</td><td class="fielddoc"><p>The application supplied slave address is too wide. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga96b1078c3d1494d305c9b7e4103e4cafaf5f5c30a31938a71f438b8efcde39340"></a>ADI_I2C_INVALID_SUBMIT_API&#160;</td><td class="fielddoc"><p>Unmatched read/write vs. submit/get API call. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga96b1078c3d1494d305c9b7e4103e4cafadd8a56fc50ccc323299866d8f2809279"></a>ADI_I2C_SEMAPHORE_FAILED&#160;</td><td class="fielddoc"><p>Semaphore operation failed. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="adi__i2c_8h_source.html#l00086">86</a> of file <a class="el" href="adi__i2c_8h_source.html">adi_i2c.h</a>.</p>

</div>
</div>
<a id="ga3f9b7f99a70885ddddd12a48f274f820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f9b7f99a70885ddddd12a48f274f820">&#9670;&nbsp;</a></span>ADI_I2C_HW_ERRORS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c___driver.html#ga3f9b7f99a70885ddddd12a48f274f820">ADI_I2C_HW_ERRORS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C Device Hardware Error Codes. Contains one or more hardware (I2C protocol) errors. Use this enum to decode hardware errors when the main <a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a> return result value is <a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa6763c65d020ffb6136012e271430de94">ADI_I2C_HW_ERROR_DETECTED</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3f9b7f99a70885ddddd12a48f274f820af3facc96a965fd4096f403fcc05d48be"></a>ADI_I2C_HW_ERROR_NONE&#160;</td><td class="fielddoc"><p>No hardware error. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f9b7f99a70885ddddd12a48f274f820a102f8ef230c4d5ec658d98b115e08ad2"></a>ADI_I2C_HW_ERROR_NACK_ADDR&#160;</td><td class="fielddoc"><p>A no-acknowledgement occurred for the address. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f9b7f99a70885ddddd12a48f274f820a8f84e914a7135399f1e10a1c9b1e75e3"></a>ADI_I2C_HW_ERROR_NACK_DATA&#160;</td><td class="fielddoc"><p>A no-acknowledgement occurred for the data. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f9b7f99a70885ddddd12a48f274f820ae62c179c01593380fabba5e6f70f2e95"></a>ADI_I2C_HW_ERROR_ARBITRATION_LOST&#160;</td><td class="fielddoc"><p>I2C bus arbitration was Lost. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3f9b7f99a70885ddddd12a48f274f820a3fa62b7541b4391d29335f19dca5e2d0"></a>ADI_I2C_HW_ERROR_UNEXPECTED_ERROR&#160;</td><td class="fielddoc"><p>An unexpected error occurred. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="adi__i2c_8h_source.html#l00115">115</a> of file <a class="el" href="adi__i2c_8h_source.html">adi_i2c.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga169717b204e91c7a5a0c3acb98fbf3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga169717b204e91c7a5a0c3acb98fbf3aa">&#9670;&nbsp;</a></span>adi_i2c_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a> adi_i2c_Open </td>
          <td>(</td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>DeviceNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pMemory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>MemorySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> *const&#160;</td>
          <td class="paramname"><em>phDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize and allocate an I2C device for use in Master Mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">DeviceNum</td><td>Zero-based device index designating the I2C device to initialize.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMemory</td><td>Pointer to a 32-bit aligned buffer of size ADI_I2C_MEMORY_SIZE required by the driver for the operation of specified I2C device.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MemorySize</td><td>Size of the buffer to which "pMemory" points.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">phDevice</td><td>The caller's device handle pointer for storing the initialized device instance data pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaa9d1b5a54050b4445fbf155b9eb337d6">ADI_I2C_SUCCESS</a> Call completed successfully.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa00af783932ab386f10452892575d0be4">ADI_I2C_BAD_DEVICE_NUMBER</a> [D] Invalid device index.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafae71f46e60ba8e66db584a49292bf45d3">ADI_I2C_DEVICE_IN_USE</a> [D] Device is already opened.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa58170da1dacc86327c2d09c51484cb7a">ADI_I2C_INSUFFICIENT_MEMORY</a> [D] Device memory is not sufficient.</li>
</ul>
</dd></dl>
<p>Initialize an I2C device using default user configuration settings (from <a class="el" href="adi__i2c__config_8h_source.html" title=": Configuration options for I2C driver. This is specific to the I2C driver and will be included by th...">adi_i2c_config.h</a>) and allocate the device for use. Device is opened in Master mode only.</p>
<p>No other I2C APIs may be called until the device open function is called. The returned device handle is required to be passed to all subsequent I2C API calls to identify the physical device instance to use. The user device handle (pointed to by phDevice) is set to NULL on failure.</p>
<dl class="section note"><dt>Note</dt><dd>Currently, only a singular I2C physical device instance (device ID "0") exists.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___driver.html#ga0d8281f399c6a73178a825703c42df19" title="Uninitialize and deallocate an SPI device. ">adi_spi_Close()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__i2c_8c_source.html#l00181">181</a> of file <a class="el" href="adi__i2c_8c_source.html">adi_i2c.c</a>.</p>

</div>
</div>
<a id="ga0afc18d59e87e826bccb210e6f559c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0afc18d59e87e826bccb210e6f559c5b">&#9670;&nbsp;</a></span>adi_i2c_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a> adi_i2c_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uninitialize and deallocate an I2C device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___s_p_i___driver.html#gabc174afa64ffce531d2dba11e054254a" title="Initialize and allocate an SPI device for use in Master Mode. ">adi_spi_Open()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaa9d1b5a54050b4445fbf155b9eb337d6">ADI_I2C_SUCCESS</a> Call completed successfully.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa4c7159a2670ef615e7e9860aba9ae7de">ADI_I2C_BAD_DEVICE_HANDLE</a> [D] Invalid device handle parameter.</li>
</ul>
</dd></dl>
<p>Uninitialize and release an allocated I2C device, and memory associated with it for other use.</p>
<dl class="section note"><dt>Note</dt><dd>The user memory is released from use by the I2C driver, but is not freed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___s_p_i___driver.html#gabc174afa64ffce531d2dba11e054254a" title="Initialize and allocate an SPI device for use in Master Mode. ">adi_spi_Open()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__i2c_8c_source.html#l00278">278</a> of file <a class="el" href="adi__i2c_8c_source.html">adi_i2c.c</a>.</p>

</div>
</div>
<a id="gace0149b86e9f4bc42d8597c498428b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace0149b86e9f4bc42d8597c498428b9b">&#9670;&nbsp;</a></span>adi_i2c_ReadWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a> adi_i2c_ReadWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_d_i___i2_c___t_r_a_n_s_a_c_t_i_o_n.html">ADI_I2C_TRANSACTION</a> *const&#160;</td>
          <td class="paramname"><em>pTransaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>pHwErrors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking I2C Master-Mode data read/write API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___s_p_i___driver.html#gabc174afa64ffce531d2dba11e054254a" title="Initialize and allocate an SPI device for use in Master Mode. ">adi_spi_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pTransaction</td><td>Pointer to I2C transaction data struct. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pHwErrors</td><td>Pointer to hardware error return variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaa9d1b5a54050b4445fbf155b9eb337d6">ADI_I2C_SUCCESS</a> Call completed successfully.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa4c7159a2670ef615e7e9860aba9ae7de">ADI_I2C_BAD_DEVICE_HANDLE</a> [D] Invalid device handle parameter.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafae71f46e60ba8e66db584a49292bf45d3">ADI_I2C_DEVICE_IN_USE</a> [D] An I2C transaction is already underway.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafacec357b8230c26c2c1dfc4db34c7bce2">ADI_I2C_INVALID_PARAMETER</a> [D] Invalid data pointer or count is detected.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa6763c65d020ffb6136012e271430de94">ADI_I2C_HW_ERROR_DETECTED</a> A hardware error occurred, check <em>pHwErrors</em>.</li>
</ul>
</dd></dl>
<p>Request a blocking I2C data transfer (read or write, not both as I2C is unidirectional bus) with or without preceding prologue transmitted. Control is not returned to the calling application until the transfer is complete. Buffer allocations are made by the calling code (the application).</p>
<p>The optional prologue (if present) and MANDATORY transaction data pointers are used to read or write data over the I2C serial bus according to the prologue and data pointers and corresponding size information contained in the <em>pTransaction</em> parameter block. The most recently set slave target address (set statically with user configuration settings contained in <a class="el" href="adi__i2c__config_8h_source.html" title=": Configuration options for I2C driver. This is specific to the I2C driver and will be included by th...">adi_i2c_config.h</a> file or set dynamically (at run-time) via the <a class="el" href="group___i2_c___driver.html#ga4dc8aa35c637be870fa7be6c258dbcc2" title="Set the I2C serial bus slave address. ">adi_i2c_SetSlaveAddress()</a> API) is used to address the specific destination slave device on the I2C bus.</p>
<p>If present, the prologue (typically, an addressing phase conveying a memory/register address or slave device command) is transmitted prior to the data read or write phase, with or without an intervening I2C STOP condition. The prologue data is entirely slave device dependent.</p>
<p>In the case of a prologue followed by a data read operation, the I2C bus direction must be reversed following the prologue transmit. In this case, The usual I2C STOP condition following the prologue (if present) transmit may be suppressed by setting the <em>bRepeatStart</em> transaction parameter "true". In this case, a second (repeat) START condition is "transmitted" between the addressing phase (prologue transmit) and the data phase of the read sequence... <em>without</em> an intervening STOP condition. This is commonly referred to as the "combined format" in which the I2C bus direction is reversed halfway through the transaction without releasing control of the I2C bus arbitration. The REPEAT-START condition is a common I2C bus protocol required by many I2C slave devices.</p>
<p>In the case of a prologue followed by a data write operation, there is no need to turn the bus around and so the <em>bRepeatStart</em> parameter is ignored.</p>
<dl class="section note"><dt>Note</dt><dd>Application must check the return code to verify if any I2C Bus errors occurred. Hardware errors (I2C Protocol errors) are indicated with the <a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa6763c65d020ffb6136012e271430de94">ADI_I2C_HW_ERROR_DETECTED</a> return code, and the set of hardware errors (enum <a class="el" href="group___i2_c___driver.html#ga3f9b7f99a70885ddddd12a48f274f820">ADI_I2C_HW_ERRORS</a>) that occurred (there may be multiple) are indicated in the value set to user variable pointed to by <em>pHwErrors</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___driver.html#ga4dc8aa35c637be870fa7be6c258dbcc2" title="Set the I2C serial bus slave address. ">adi_i2c_SetSlaveAddress()</a>. </dd>
<dd>
<a class="el" href="group___i2_c___driver.html#gac898de0c211c2fccfc4f3760ac1c9eb6" title="Non-Blocking I2C Master-Mode data read or data write API. ">adi_i2c_SubmitBuffer()</a>. </dd>
<dd>
<a class="el" href="group___i2_c___driver.html#gae849d5bb1db5df5f8c41fb5dd26fd335" title="Query if a non-blocking I2C transfer is complete. ">adi_i2c_IsBufferAvailable()</a>. </dd>
<dd>
<a class="el" href="group___i2_c___driver.html#ga501a115731f2b6c61f9371fafb93b9cc" title="Request ownership of a submitted buffer. ">adi_i2c_GetBuffer()</a>. </dd>
<dd>
<a class="el" href="struct_a_d_i___i2_c___t_r_a_n_s_a_c_t_i_o_n.html">ADI_I2C_TRANSACTION</a>. </dd>
<dd>
<a class="el" href="group___i2_c___driver.html#ga3f9b7f99a70885ddddd12a48f274f820">ADI_I2C_HW_ERRORS</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__i2c_8c_source.html#l00355">355</a> of file <a class="el" href="adi__i2c_8c_source.html">adi_i2c.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="adi__i2c_8c_source.html#l00789">adi_i2c_IssueGeneralCall()</a>.</p>

</div>
</div>
<a id="gac898de0c211c2fccfc4f3760ac1c9eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac898de0c211c2fccfc4f3760ac1c9eb6">&#9670;&nbsp;</a></span>adi_i2c_SubmitBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a> adi_i2c_SubmitBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_d_i___i2_c___t_r_a_n_s_a_c_t_i_o_n.html">ADI_I2C_TRANSACTION</a> *const&#160;</td>
          <td class="paramname"><em>pTransaction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-Blocking I2C Master-Mode data read or data write API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___s_p_i___driver.html#gabc174afa64ffce531d2dba11e054254a" title="Initialize and allocate an SPI device for use in Master Mode. ">adi_spi_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pTransaction</td><td>Pointer to I2C transaction data struct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaa9d1b5a54050b4445fbf155b9eb337d6">ADI_I2C_SUCCESS</a> Call completed successfully.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa4c7159a2670ef615e7e9860aba9ae7de">ADI_I2C_BAD_DEVICE_HANDLE</a> [D] Invalid device handle parameter.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafae71f46e60ba8e66db584a49292bf45d3">ADI_I2C_DEVICE_IN_USE</a> [D] An I2C transaction is already underway.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafacec357b8230c26c2c1dfc4db34c7bce2">ADI_I2C_INVALID_PARAMETER</a> [D] Invalid data pointer or count is detected.</li>
</ul>
</dd></dl>
<p>Request a non-blocking I2C data transfer (read or write) with or without preceding prologue transmitted. Control is returned to the calling application immediately, allowing the application process other tasks. The transaction result code is retrieved by <a class="el" href="group___i2_c___driver.html#ga501a115731f2b6c61f9371fafb93b9cc" title="Request ownership of a submitted buffer. ">adi_i2c_GetBuffer()</a>.</p>
<p>The application may optionally poll the I2C driver via the <a class="el" href="group___i2_c___driver.html#gae849d5bb1db5df5f8c41fb5dd26fd335" title="Query if a non-blocking I2C transfer is complete. ">adi_i2c_IsBufferAvailable()</a> API while the transaction is underway to determine if and when the submitted transaction is complete. Eventually, the application <em>MUST</em> call the <em>MANDATORY</em> <a class="el" href="group___i2_c___driver.html#ga501a115731f2b6c61f9371fafb93b9cc" title="Request ownership of a submitted buffer. ">adi_i2c_GetBuffer()</a> API to obtain the transaction result and complete the transaction. Buffer allocations are made by the calling code (the application).</p>
<p>The <a class="el" href="group___i2_c___driver.html#ga501a115731f2b6c61f9371fafb93b9cc" title="Request ownership of a submitted buffer. ">adi_i2c_GetBuffer()</a> API may be called at any time, even if the transaction is incomplete; the <a class="el" href="group___i2_c___driver.html#ga501a115731f2b6c61f9371fafb93b9cc" title="Request ownership of a submitted buffer. ">adi_i2c_GetBuffer()</a> call will simply block in incomplete transactions until the transaction does complete... at which point <a class="el" href="group___i2_c___driver.html#ga501a115731f2b6c61f9371fafb93b9cc" title="Request ownership of a submitted buffer. ">adi_i2c_GetBuffer()</a> returns control with the transaction result code. Submitting background transactions is useful if the application has housekeeping chores to perform when the I2C transaction is started, but later the application decides to just block until the transaction is complete.</p>
<p>The prologue and data buffers are handled as they are in the blocking <a class="el" href="group___i2_c___driver.html#gace0149b86e9f4bc42d8597c498428b9b" title="Blocking I2C Master-Mode data read/write API. ">adi_i2c_ReadWrite()</a> call, it's just that the <a class="el" href="group___i2_c___driver.html#gac898de0c211c2fccfc4f3760ac1c9eb6" title="Non-Blocking I2C Master-Mode data read or data write API. ">adi_i2c_SubmitBuffer()</a> API does not block on the data phase.</p>
<dl class="section note"><dt>Note</dt><dd>The non-blocking <a class="el" href="group___i2_c___driver.html#gac898de0c211c2fccfc4f3760ac1c9eb6" title="Non-Blocking I2C Master-Mode data read or data write API. ">adi_i2c_SubmitBuffer()</a> call <em>REQUIRES</em> a matching <a class="el" href="group___i2_c___driver.html#ga501a115731f2b6c61f9371fafb93b9cc" title="Request ownership of a submitted buffer. ">adi_i2c_GetBuffer()</a> call to obtain the final transaction result code and to inform the driver that the application wants to regain ownership of the buffers. The application should be prepared to wait for this ownership until the current transaction completes. The matching <a class="el" href="group___i2_c___driver.html#ga501a115731f2b6c61f9371fafb93b9cc" title="Request ownership of a submitted buffer. ">adi_i2c_GetBuffer()</a> call is required even if the transaction may have already completed. The <a class="el" href="group___i2_c___driver.html#ga501a115731f2b6c61f9371fafb93b9cc" title="Request ownership of a submitted buffer. ">adi_i2c_GetBuffer()</a> call allows the driver to block on completion or error events and then synchronize its internal blocking object. The intermediate <a class="el" href="group___i2_c___driver.html#gae849d5bb1db5df5f8c41fb5dd26fd335" title="Query if a non-blocking I2C transfer is complete. ">adi_i2c_IsBufferAvailable()</a> API is optional.<br />
<br />
 </dd>
<dd>
The <a class="el" href="group___i2_c___driver.html#gac898de0c211c2fccfc4f3760ac1c9eb6" title="Non-Blocking I2C Master-Mode data read or data write API. ">adi_i2c_SubmitBuffer()</a> API is singular, i.e., only a single transaction may be submitted at a time. Simultaneous submits (e.g., ping-pong mode) are not supported by the I2C driver.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___driver.html#gace0149b86e9f4bc42d8597c498428b9b" title="Blocking I2C Master-Mode data read/write API. ">adi_i2c_ReadWrite()</a>. </dd>
<dd>
<a class="el" href="group___i2_c___driver.html#ga4dc8aa35c637be870fa7be6c258dbcc2" title="Set the I2C serial bus slave address. ">adi_i2c_SetSlaveAddress()</a>. </dd>
<dd>
<a class="el" href="group___i2_c___driver.html#gae849d5bb1db5df5f8c41fb5dd26fd335" title="Query if a non-blocking I2C transfer is complete. ">adi_i2c_IsBufferAvailable()</a>. </dd>
<dd>
<a class="el" href="group___i2_c___driver.html#ga501a115731f2b6c61f9371fafb93b9cc" title="Request ownership of a submitted buffer. ">adi_i2c_GetBuffer()</a>. </dd>
<dd>
<a class="el" href="struct_a_d_i___i2_c___t_r_a_n_s_a_c_t_i_o_n.html">ADI_I2C_TRANSACTION</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__i2c_8c_source.html#l00450">450</a> of file <a class="el" href="adi__i2c_8c_source.html">adi_i2c.c</a>.</p>

</div>
</div>
<a id="gae849d5bb1db5df5f8c41fb5dd26fd335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae849d5bb1db5df5f8c41fb5dd26fd335">&#9670;&nbsp;</a></span>adi_i2c_IsBufferAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a> adi_i2c_IsBufferAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *const&#160;</td>
          <td class="paramname"><em>pbCompletionState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query if a non-blocking I2C transfer is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___s_p_i___driver.html#gabc174afa64ffce531d2dba11e054254a" title="Initialize and allocate an SPI device for use in Master Mode. ">adi_spi_Open()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pbCompletionState</td><td>Pointer to Boolean into which the I2C bus state is written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaa9d1b5a54050b4445fbf155b9eb337d6">ADI_I2C_SUCCESS</a> Call completed successfully.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa4c7159a2670ef615e7e9860aba9ae7de">ADI_I2C_BAD_DEVICE_HANDLE</a> [D] Invalid device handle parameter.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaf5f5c30a31938a71f438b8efcde39340">ADI_I2C_INVALID_SUBMIT_API</a> No matching submit call.</li>
</ul>
</dd></dl>
<p>Sets the application-provided Boolean variable pointed to by pbCompletionState either:</p><ul>
<li>true, when the non-blocking transactions is complete, or</li>
<li>false, while the non-blocking transactions is still underway.</li>
</ul>
<p>This API is used in conjunction with a non-blocking <a class="el" href="group___i2_c___driver.html#gac898de0c211c2fccfc4f3760ac1c9eb6" title="Non-Blocking I2C Master-Mode data read or data write API. ">adi_i2c_SubmitBuffer()</a> transfer to determine when the transaction is complete. Typically, non-blocking calls are used when the calling application has other work to do while I2C controller serializes data over the I2C bus, which is an interrupt-driven process. The transaction is submitted as a non-blocking call and the submitting API returns immediately, allowing the calling application to perform its other tasks. The I2C driver services the interrupts to transfer data while the application performs its other tasks.</p>
<p>Non-blocking calls can be polled with this API for completion, or if the application has completed its other tasks and wants to just wait on the I2C completion without further polling, it may call the associated <a class="el" href="group___i2_c___driver.html#ga501a115731f2b6c61f9371fafb93b9cc" title="Request ownership of a submitted buffer. ">adi_i2c_GetBuffer()</a> API to convert the currently unblocked transaction to a blocking one.</p>
<dl class="section note"><dt>Note</dt><dd>This API is inappropriate in context of blocking calls to <a class="el" href="group___i2_c___driver.html#gace0149b86e9f4bc42d8597c498428b9b" title="Blocking I2C Master-Mode data read/write API. ">adi_i2c_ReadWrite()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___driver.html#gace0149b86e9f4bc42d8597c498428b9b" title="Blocking I2C Master-Mode data read/write API. ">adi_i2c_ReadWrite()</a>. </dd>
<dd>
<a class="el" href="group___i2_c___driver.html#gac898de0c211c2fccfc4f3760ac1c9eb6" title="Non-Blocking I2C Master-Mode data read or data write API. ">adi_i2c_SubmitBuffer()</a>. </dd>
<dd>
<a class="el" href="group___i2_c___driver.html#ga501a115731f2b6c61f9371fafb93b9cc" title="Request ownership of a submitted buffer. ">adi_i2c_GetBuffer()</a>. </dd>
<dd>
<a class="el" href="struct_a_d_i___i2_c___t_r_a_n_s_a_c_t_i_o_n.html">ADI_I2C_TRANSACTION</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__i2c_8c_source.html#l00511">511</a> of file <a class="el" href="adi__i2c_8c_source.html">adi_i2c.c</a>.</p>

</div>
</div>
<a id="ga501a115731f2b6c61f9371fafb93b9cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga501a115731f2b6c61f9371fafb93b9cc">&#9670;&nbsp;</a></span>adi_i2c_GetBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a> adi_i2c_GetBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>pHwErrors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request ownership of a submitted buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___s_p_i___driver.html#gabc174afa64ffce531d2dba11e054254a" title="Initialize and allocate an SPI device for use in Master Mode. ">adi_spi_Open()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pHwErrors</td><td>Pointer to hardware error return variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaa9d1b5a54050b4445fbf155b9eb337d6">ADI_I2C_SUCCESS</a> Call completed successfully.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa4c7159a2670ef615e7e9860aba9ae7de">ADI_I2C_BAD_DEVICE_HANDLE</a> [D] Invalid device handle parameter.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaf5f5c30a31938a71f438b8efcde39340">ADI_I2C_INVALID_SUBMIT_API</a> No matching submit call.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa6763c65d020ffb6136012e271430de94">ADI_I2C_HW_ERROR_DETECTED</a> A hardware error occurred, check <em>pHwErrors</em>.</li>
</ul>
</dd></dl>
<p>This is a potentially blocking MANDATORY call that the application MUST use to reclaim ownership of any "submitted" transaction (submitted via a previous <a class="el" href="group___i2_c___driver.html#gac898de0c211c2fccfc4f3760ac1c9eb6" title="Non-Blocking I2C Master-Mode data read or data write API. ">adi_i2c_SubmitBuffer()</a> call) and obtain the transaction success/failure result code. This API blocks until the transaction is complete and returns the transaction result code. If the transaction is already complete, the blocking is trivial and control is returned immediately.</p>
<p>Non-blocking calls can also be (optionally) polled with the non-blocking <a class="el" href="group___i2_c___driver.html#gae849d5bb1db5df5f8c41fb5dd26fd335" title="Query if a non-blocking I2C transfer is complete. ">adi_i2c_IsBufferAvailable()</a> API to see if and when the transaction is complete.</p>
<p>The <a class="el" href="group___i2_c___driver.html#ga501a115731f2b6c61f9371fafb93b9cc" title="Request ownership of a submitted buffer. ">adi_i2c_GetBuffer()</a> call is a MANDATORY compliment to <a class="el" href="group___i2_c___driver.html#gac898de0c211c2fccfc4f3760ac1c9eb6" title="Non-Blocking I2C Master-Mode data read or data write API. ">adi_i2c_SubmitBuffer()</a> and allows the I2C driver to synchronize its internal blocking object.</p>
<dl class="section note"><dt>Note</dt><dd>Application must check the return code to verify if any I2C Bus errors occurred. Hardware errors (I2C Protocol errors) are indicated with the <a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa6763c65d020ffb6136012e271430de94">ADI_I2C_HW_ERROR_DETECTED</a> return code, and the set of hardware errors (enum <a class="el" href="group___i2_c___driver.html#ga3f9b7f99a70885ddddd12a48f274f820">ADI_I2C_HW_ERRORS</a>) that occurred (there may be multiple) are indicated in the value set to user variable pointed to by <em>pHwErrors</em>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___driver.html#gace0149b86e9f4bc42d8597c498428b9b" title="Blocking I2C Master-Mode data read/write API. ">adi_i2c_ReadWrite()</a>. </dd>
<dd>
<a class="el" href="group___i2_c___driver.html#gac898de0c211c2fccfc4f3760ac1c9eb6" title="Non-Blocking I2C Master-Mode data read or data write API. ">adi_i2c_SubmitBuffer()</a>. </dd>
<dd>
<a class="el" href="group___i2_c___driver.html#gae849d5bb1db5df5f8c41fb5dd26fd335" title="Query if a non-blocking I2C transfer is complete. ">adi_i2c_IsBufferAvailable()</a>. </dd>
<dd>
<a class="el" href="struct_a_d_i___i2_c___t_r_a_n_s_a_c_t_i_o_n.html">ADI_I2C_TRANSACTION</a>. </dd>
<dd>
<a class="el" href="group___i2_c___driver.html#ga3f9b7f99a70885ddddd12a48f274f820">ADI_I2C_HW_ERRORS</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__i2c_8c_source.html#l00570">570</a> of file <a class="el" href="adi__i2c_8c_source.html">adi_i2c.c</a>.</p>

</div>
</div>
<a id="ga5a6635aef9a5eb9d31793cd5ae86f9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a6635aef9a5eb9d31793cd5ae86f9b2">&#9670;&nbsp;</a></span>adi_i2c_Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a> adi_i2c_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset an I2C device and driver instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___s_p_i___driver.html#gabc174afa64ffce531d2dba11e054254a" title="Initialize and allocate an SPI device for use in Master Mode. ">adi_spi_Open()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaa9d1b5a54050b4445fbf155b9eb337d6">ADI_I2C_SUCCESS</a> Call completed successfully.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa4c7159a2670ef615e7e9860aba9ae7de">ADI_I2C_BAD_DEVICE_HANDLE</a> [D] Invalid device handle parameter.</li>
</ul>
</dd></dl>
<p>Reset the I2C physical controller and device driver internals. </p>

<p class="definition">Definition at line <a class="el" href="adi__i2c_8c_source.html#l00613">613</a> of file <a class="el" href="adi__i2c_8c_source.html">adi_i2c.c</a>.</p>

</div>
</div>
<a id="gaabc8225a8d55e062cb0fde16e3a89adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabc8225a8d55e062cb0fde16e3a89adb">&#9670;&nbsp;</a></span>adi_i2c_SetBitRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a> adi_i2c_SetBitRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>requestedBitRate32</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the I2C serial bus speed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___s_p_i___driver.html#gabc174afa64ffce531d2dba11e054254a" title="Initialize and allocate an SPI device for use in Master Mode. ">adi_spi_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requestedBitRate32</td><td>Requested I2C bus clock rate (in Hz).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaa9d1b5a54050b4445fbf155b9eb337d6">ADI_I2C_SUCCESS</a> Call completed successfully.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa4c7159a2670ef615e7e9860aba9ae7de">ADI_I2C_BAD_DEVICE_HANDLE</a> [D] Invalid device handle parameter.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafae71f46e60ba8e66db584a49292bf45d3">ADI_I2C_DEVICE_IN_USE</a> [D] Device is busy.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaba5ae0b4598a8476132724a7bb084679">ADI_I2C_BAD_SYS_CLOCK</a> Failure to obtain the current PCLK rate.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa4d2fbe391bb9610de1af5b067b4879a0">ADI_I2C_BAD_BITRATE</a> Requested clock speed exceeds operational specification.</li>
</ul>
</dd></dl>
<p>Sets the I2C bus clock speed to the requested user parameter, <em>requestedBitRate</em>.</p>
<dl class="section note"><dt>Note</dt><dd>Any I2C Bus clock rate may be requested up to and including the "FAST" mode I2C clock rate (400 kHz), including the "STANDARD" mode (100 kHz). Faster clock rates beyond "FAST" mode (e.g., "FAST+" or "HIGH-SPEED" modes) are not supported by the hardware. Slower clock rates below approximately 55 kHz (assuming a 26 MHz system clock) are physically unrealizable due to the fixed 8-bit field-width of the 8-bit I2C clock rate divide register.<br />
<br />
 </dd>
<dd>
Default clock rate may be specified statically in the default user configuration file, "adi_i2c_config.h". </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__i2c_8c_source.html#l00656">656</a> of file <a class="el" href="adi__i2c_8c_source.html">adi_i2c.c</a>.</p>

</div>
</div>
<a id="ga4dc8aa35c637be870fa7be6c258dbcc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dc8aa35c637be870fa7be6c258dbcc2">&#9670;&nbsp;</a></span>adi_i2c_SetSlaveAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a> adi_i2c_SetSlaveAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t const&#160;</td>
          <td class="paramname"><em>SlaveAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the I2C serial bus slave address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___s_p_i___driver.html#gabc174afa64ffce531d2dba11e054254a" title="Initialize and allocate an SPI device for use in Master Mode. ">adi_spi_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SlaveAddress</td><td>New 7-bit address for targeting a slave device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaa9d1b5a54050b4445fbf155b9eb337d6">ADI_I2C_SUCCESS</a> Call completed successfully.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa4c7159a2670ef615e7e9860aba9ae7de">ADI_I2C_BAD_DEVICE_HANDLE</a> [D] Invalid device handle parameter.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafae71f46e60ba8e66db584a49292bf45d3">ADI_I2C_DEVICE_IN_USE</a> [D] Device is busy.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa963cec75f2dfb386635f9478c1891d28">ADI_I2C_INVALID_SLAVE_ADDRESS</a> Slave address exceeds the 7-bit limit.</li>
</ul>
</dd></dl>
<p>Sets the 7-bit (unformatted) slave address for which all subsequent I2C bus traffic is directed. Read/write address formatting is performed by the driver, depending on bus direction.</p>
<dl class="section note"><dt>Note</dt><dd>This driver does not support the I2C 10-bit extended addressing scheme.<br />
<br />
 </dd>
<dd>
Default slave address may be specified statically in the default user configuration file, "adi_i2c_config.h". </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__i2c_8c_source.html#l00735">735</a> of file <a class="el" href="adi__i2c_8c_source.html">adi_i2c.c</a>.</p>

</div>
</div>
<a id="ga13b61881e8c5282ed94d5902c2901a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13b61881e8c5282ed94d5902c2901a17">&#9670;&nbsp;</a></span>adi_i2c_IssueGeneralCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c___driver.html#ga96b1078c3d1494d305c9b7e4103e4caf">ADI_I2C_RESULT</a> adi_i2c_IssueGeneralCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___i2_c___driver.html#ga34a6d8c01e422cb46c0999ad1ec624be">ADI_I2C_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const&#160;</td>
          <td class="paramname"><em>nDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>pHwErrors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a General Call command to all slave devices on the I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___s_p_i___driver.html#gabc174afa64ffce531d2dba11e054254a" title="Initialize and allocate an SPI device for use in Master Mode. ">adi_spi_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>Pointer to data buffer to transmit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDataSize</td><td>Size of data buffer to transmit. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pHwErrors</td><td>Pointer to hardware error return variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafaa9d1b5a54050b4445fbf155b9eb337d6">ADI_I2C_SUCCESS</a> Call completed successfully.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafa4c7159a2670ef615e7e9860aba9ae7de">ADI_I2C_BAD_DEVICE_HANDLE</a> [D] Invalid device handle parameter.</li>
<li><a class="el" href="group___i2_c___driver.html#gga96b1078c3d1494d305c9b7e4103e4cafae71f46e60ba8e66db584a49292bf45d3">ADI_I2C_DEVICE_IN_USE</a> [D] Device is busy.</li>
</ul>
</dd></dl>
<p>Broadcasts the given command buffer across the I2C bus to reserved General Call (GC) address (address zero). All, some, or none of the slave devices on the I2C bus will respond, depending on their capabilities. All responding slave devices will process the GC command according to their capabilities.</p>
<p>The GC command is a blocking transaction.</p>
<p>The application is responsible for formatting the GC command into the data buffer according to various Philips Semiconductor (now, NXP) documents, such as the 2014 Revision 6 document: "UM10204 I2C-Bus Specification and User Manual" (see www.nxp.com/documents/user_manual/UM10204.pdf).</p>
<p>No prologue precedes the GC command data; the GC command data is transmitted verbatim.</p>
<dl class="section note"><dt>Note</dt><dd>The currently active slave address is saved and restored when transmitting GC commands to the reserved GC address (address zero). </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__i2c_8c_source.html#l00789">789</a> of file <a class="el" href="adi__i2c_8c_source.html">adi_i2c.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Aug 6 2018 21:48:23 for ADuCM302x Device Drivers API Reference Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
