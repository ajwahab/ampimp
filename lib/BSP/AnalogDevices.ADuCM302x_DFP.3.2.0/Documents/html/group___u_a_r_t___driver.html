<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ADuCM302x Device Drivers API Reference Manual: UART Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ADuCM302x Device Drivers API Reference Manual
   &#160;<span id="projectnumber">Release 3.1.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___u_a_r_t___driver.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UART Driver</div>  </div>
</div><!--header-->
<div class="contents">

<p>UART Driver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___u_a_r_t___driver___config"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver___config.html">Static Configuration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga3be96bbdc8dc0925104d423b1e2d4a24"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga3be96bbdc8dc0925104d423b1e2d4a24">ADI_UART_UNIDIR_MEMORY_SIZE</a>&#160;&#160;&#160;(48u + (60u + ADI_SEM_SIZE))</td></tr>
<tr class="separator:ga3be96bbdc8dc0925104d423b1e2d4a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64cf5eea242e232b91092933291997e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gaa64cf5eea242e232b91092933291997e">ADI_UART_BIDIR_MEMORY_SIZE</a>&#160;&#160;&#160;(48u + (60u + ADI_SEM_SIZE)*2u)</td></tr>
<tr class="separator:gaa64cf5eea242e232b91092933291997e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e01b4f3118ba363a6e6ddc6239bcb86"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga7e01b4f3118ba363a6e6ddc6239bcb86">ADI_UART_NUM_DEVICES</a>&#160;&#160;&#160;(sizeof(uart_device_info)/sizeof(ADI_UART_DEVICE_INFO))</td></tr>
<tr class="separator:ga7e01b4f3118ba363a6e6ddc6239bcb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga13d69dc9cf05cd8e6f2983db6d7b99bf"><td class="memItemLeft" align="right" valign="top">typedef struct _ADI_UART_DEVICE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a></td></tr>
<tr class="separator:ga13d69dc9cf05cd8e6f2983db6d7b99bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e3e8bd6d22a548d8ca2d9512a81eca2"><td class="memItemLeft" align="right" valign="top">typedef const struct _ADI_UART_DEVICE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga7e3e8bd6d22a548d8ca2d9512a81eca2">ADI_UART_CONST_HANDLE</a></td></tr>
<tr class="separator:ga7e3e8bd6d22a548d8ca2d9512a81eca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gafba0edfc161e68df641d6d9aa29d9592"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gafba0edfc161e68df641d6d9aa29d9592">ADI_UART_DIRECTION</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggafba0edfc161e68df641d6d9aa29d9592aec0a24292b639687f3d072aa42c3c7be">ADI_UART_DIR_TRANSMIT</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggafba0edfc161e68df641d6d9aa29d9592a3f08f517a5b5d7f3d1ff528c6cf0825f">ADI_UART_DIR_RECEIVE</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggafba0edfc161e68df641d6d9aa29d9592acedb60591f41cca300937c47625ee6e2">ADI_UART_DIR_BIDIRECTION</a>
<br />
 }</td></tr>
<tr class="separator:gafba0edfc161e68df641d6d9aa29d9592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad15ce602aed9ffcf2cd582c20063681e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gad15ce602aed9ffcf2cd582c20063681e">ADI_UART_EVENT</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggad15ce602aed9ffcf2cd582c20063681ea146a079fc37b9d05b2387ae6900699be">ADI_UART_EVENT_RX_BUFFER_PROCESSED</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggad15ce602aed9ffcf2cd582c20063681ea3b48fc09131e9ae59e2cf69b4969efea">ADI_UART_EVENT_TX_BUFFER_PROCESSED</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggad15ce602aed9ffcf2cd582c20063681eaac9ba794e8cb2414b08dda670a0a60a0">ADI_UART_EVENT_NO_RX_BUFFER_EVENT</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggad15ce602aed9ffcf2cd582c20063681eaf402ac6e2bf17e5f8c0a2c7e6617bcfd">ADI_UART_EVENT_AUTOBAUD_COMPLETE</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggad15ce602aed9ffcf2cd582c20063681ea4a3eef2ee79b3a80ce717c878c8c71e2">ADI_UART_EVENT_HW_ERROR_DETECTED</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggad15ce602aed9ffcf2cd582c20063681ea2736950d6c87b60ce501de07f479bd25">ADI_UART_EVENT_AUTOBAUD_ERROR_DETECTED</a>
<br />
 }</td></tr>
<tr class="separator:gad15ce602aed9ffcf2cd582c20063681e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5faa34dee86e0fd8ff9d79d7003ad526fb7">ADI_UART_FAILED</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fad2b401b149870f9574592dcc4f101df6">ADI_UART_SEMAPHORE_FAILED</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8f3f6a7234347e32da9ca6d930ac0ccc">ADI_UART_DEVICE_IN_USE</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa0b182e30b8cc33f9fc68fff65f96652a">ADI_UART_INVALID_DEVICE_NUM</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa7253178a162a39ffb233ea81ef2fa39b">ADI_UART_INVALID_POINTER</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa51f399a08107be4ff84a7648b707f412">ADI_UART_INSUFFICIENT_MEMORY</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa415f5f27395dad338cacb55962096bc6">ADI_UART_INVALID_DIR</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fabc85e74a4c980b2ccb7f94b77a957a12">ADI_UART_OPERATION_NOT_ALLOWED</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa083eb7765d831faf8044f38e277c32db">ADI_UART_INVALID_PARAMETER</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5faa12d45c9dbdd6e4cf1bd90eeefb186aa">ADI_UART_BUFFER_NOT_SUBMITTED</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa04eb6c3ba9e76fd05eaaec82b678007a">ADI_UART_INVALID_DATA_TRANSFER_MODE</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8bf916459d0dc6423ba1ef87206269b2">ADI_UART_HW_ERROR_DETECTED</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa7ee065f9a049969ec1d1d0d0ff99c8d8">ADI_UART_AUTOBAUD_ERROR_DETECTED</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa461e669f6f57cf6bb98da03ce1f81b03">ADI_UART_ERR_DMA_REGISTER</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5faa622d62095733a4e1252dc8c6a47c74d">ADI_UART_INVALID_DATA_SIZE</a>
<br />
 }</td></tr>
<tr class="separator:ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa3aec3854176b7894b5ff9cd2a1bac"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gaeaa3aec3854176b7894b5ff9cd2a1bac">ADI_UART_HW_ERRORS</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggaeaa3aec3854176b7894b5ff9cd2a1baca7b1a85cc04ca252795b80f8372d1ae26">ADI_UART_NO_HW_ERROR</a> = 0x00, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggaeaa3aec3854176b7894b5ff9cd2a1bacaf91a4f5aec80730327607e0beb3a7521">ADI_UART_HW_ERR_FRAMING</a> = 0x10, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggaeaa3aec3854176b7894b5ff9cd2a1baca34e1639df91bcf3bceae7448f478a973">ADI_UART_HW_ERR_PARITY</a> = 0x20, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggaeaa3aec3854176b7894b5ff9cd2a1baca0ac969cc75d87070bc5e0857479c8b03">ADI_UART_HW_ERR_OVERRUN</a> = 0x40, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggaeaa3aec3854176b7894b5ff9cd2a1baca4fc610504a6c53fb59c71b749aecc29e">ADI_UART_BREAK_INTERRUPT</a> = 0x80, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggaeaa3aec3854176b7894b5ff9cd2a1bacacf52074c9b493e96d27fd7f3e87b9b78">ADI_UART_HW_ERR_RX_CHAN_DMA_BUS_FAULT</a> = 0x100, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggaeaa3aec3854176b7894b5ff9cd2a1baca7c6b7e3e7116427cad90ece7cd42343e">ADI_UART_HW_ERR_TX_CHAN_DMA_BUS_FAULT</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggaeaa3aec3854176b7894b5ff9cd2a1bacae910ac56187cc7d28a475d5d2c6d5a42">ADI_UART_HW_ERR_RX_CHAN_DMA_INVALID_DESCR</a> = 0x400, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggaeaa3aec3854176b7894b5ff9cd2a1baca543ccb381b7523f4d023340a79a3e821">ADI_UART_HW_ERR_TX_CHAN_DMA_INVALID_DESCR</a> = 0x800, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggaeaa3aec3854176b7894b5ff9cd2a1baca6dc27715f88fbfd4890c1fb006687e64">ADI_UART_HW_ERR_RX_CHAN_DMA_UNKNOWN_ERROR</a> = 0x1000, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggaeaa3aec3854176b7894b5ff9cd2a1baca72ee1cfe67ebef716e24fa6d76491c8f">ADI_UART_HW_ERR_TX_CHAN_DMA_UNKNOWN_ERROR</a> = 0x2000
<br />
 }</td></tr>
<tr class="separator:gaeaa3aec3854176b7894b5ff9cd2a1bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadec96e2e7c28bce540071f68d511b860"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gadec96e2e7c28bce540071f68d511b860">ADI_UART_AUTOBAUD_ERRORS</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggadec96e2e7c28bce540071f68d511b860af15ba3e093a43c3f5f81ab4b8b64046a">ADI_UART_AUTOBAUD_NO_ERROR</a> = 0x000, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggadec96e2e7c28bce540071f68d511b860a03768ff672a2a2f029bd53f4f741f47a">ADI_UART_AUTOBAUD_TIMEOUT_NO_START_EDGE</a> = 0x100, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggadec96e2e7c28bce540071f68d511b860a503620a32fb73759090bb04e6cd49131">ADI_UART_AUTOBAUD_TIMEOUT_LONGBREAK</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggadec96e2e7c28bce540071f68d511b860a496f8fc4a183b08441962ef8dc16d06b">ADI_UART_AUTOBAUD_TIMEOUT_NO_END_EDGE</a> = 0x400
<br />
 }</td></tr>
<tr class="separator:gadec96e2e7c28bce540071f68d511b860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fb94b41733ea77f181272269270b4ad"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga2fb94b41733ea77f181272269270b4ad">ADI_UART_TRIG_LEVEL</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2fb94b41733ea77f181272269270b4adaf8428503b48904789431051048f23b91">ADI_UART_RX_FIFO_TRIG_LEVEL_1BYTE</a> = 0 &lt;&lt; BITP_UART_FCR_RFTRIG, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2fb94b41733ea77f181272269270b4ada3c5108fa222ab6447f6f468e9e1f2ed7">ADI_UART_RX_FIFO_TRIG_LEVEL_4BYTE</a> = 1 &lt;&lt; BITP_UART_FCR_RFTRIG, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2fb94b41733ea77f181272269270b4adaa949bdc96833e16df5b7fa2044359acd">ADI_UART_RX_FIFO_TRIG_LEVEL_8BYTE</a> = 2 &lt;&lt; BITP_UART_FCR_RFTRIG, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga2fb94b41733ea77f181272269270b4ada04d4a09e05346e0fbf28901c64f84d16">ADI_UART_RX_FIFO_TRIG_LEVEL_14BYTE</a> = 3 &lt;&lt; BITP_UART_FCR_RFTRIG
<br />
 }</td></tr>
<tr class="separator:ga2fb94b41733ea77f181272269270b4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1ff4613eed877339134f5eec212d564"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gaa1ff4613eed877339134f5eec212d564">ADI_UART_WORDLEN</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggaa1ff4613eed877339134f5eec212d564a82b39b883aee0b5388e990dbe00402d2">ADI_UART_WORDLEN_5BITS</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggaa1ff4613eed877339134f5eec212d564a9de3e93f0b23243096c278572932e829">ADI_UART_WORDLEN_6BITS</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggaa1ff4613eed877339134f5eec212d564a2df785631993a83e6bd8f9ed73836944">ADI_UART_WORDLEN_7BITS</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggaa1ff4613eed877339134f5eec212d564a78a8e22f2b0fbe6a40ac58468cb4eb0e">ADI_UART_WORDLEN_8BITS</a>
<br />
 }</td></tr>
<tr class="separator:gaa1ff4613eed877339134f5eec212d564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e6f5ede10c8bec7107367dc6573b5e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gae2e6f5ede10c8bec7107367dc6573b5e">ADI_UART_PARITY</a> { <br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggae2e6f5ede10c8bec7107367dc6573b5ea0b6bb5e0bf17133455f5082ac6415576">ADI_UART_NO_PARITY</a> = 0x0, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggae2e6f5ede10c8bec7107367dc6573b5eadaf71abda390a58cefc9495ddcb98a4a">ADI_UART_ODD_PARITY</a> = 0x8, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggae2e6f5ede10c8bec7107367dc6573b5eac04e39137eeab046c0adcee5f359c035">ADI_UART_EVEN_PARITY</a> = 0x18, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggae2e6f5ede10c8bec7107367dc6573b5ea713a4d91d53300b0edd72cd258f1e178">ADI_UART_ODD_PARITY_STICKY</a> = 0x28, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggae2e6f5ede10c8bec7107367dc6573b5ea1366e213450367786a2d7de690fd4f75">ADI_UART_EVEN_PARITY_STICKY</a> = 0x38
<br />
 }</td></tr>
<tr class="separator:gae2e6f5ede10c8bec7107367dc6573b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbcbcbfdaa9005b03d70e8d9c0541632"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gacbcbcbfdaa9005b03d70e8d9c0541632">ADI_UART_STOPBITS</a> { <br />
&#160;&#160;<b>ADI_UART_ONE_STOPBIT</b> = 0x00, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#ggacbcbcbfdaa9005b03d70e8d9c0541632a3545d5104bf8ca48d2a0408712172803">ADI_UART_ONE_AND_HALF_TWO_STOPBITS</a> = 0x04
<br />
 }</td></tr>
<tr class="separator:gacbcbcbfdaa9005b03d70e8d9c0541632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0185ba282c0f907f5a240b7e718e7f2d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga0185ba282c0f907f5a240b7e718e7f2d">ADI_UART_TRANSFER_MODE</a> { <br />
&#160;&#160;<b>ADI_UART_DATA_TRANSFER_MODE_NONE</b>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2da3a2dc8041b22696c8136086d4fb19d86">ADI_UART_DATA_TRANSFER_MODE_BLOCKING</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>
<br />
 }</td></tr>
<tr class="separator:ga0185ba282c0f907f5a240b7e718e7f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa0237738e853bd3e25835d7037ed5a58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58">adi_uart_Open</a> (uint32_t const nDeviceNum, <a class="el" href="group___u_a_r_t___driver.html#gafba0edfc161e68df641d6d9aa29d9592">ADI_UART_DIRECTION</a> const eDirection, void *pMemory, uint32_t const nMemSize, <a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> *const phDevice)</td></tr>
<tr class="memdesc:gaa0237738e853bd3e25835d7037ed5a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization function for the UART device.  <a href="#gaa0237738e853bd3e25835d7037ed5a58">More...</a><br /></td></tr>
<tr class="separator:gaa0237738e853bd3e25835d7037ed5a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0f32765fc758abec4b444a9d5a709e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gae0f32765fc758abec4b444a9d5a709e2">adi_uart_Close</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice)</td></tr>
<tr class="memdesc:gae0f32765fc758abec4b444a9d5a709e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninitialize the memory for the specified UART instance.  <a href="#gae0f32765fc758abec4b444a9d5a709e2">More...</a><br /></td></tr>
<tr class="separator:gae0f32765fc758abec4b444a9d5a709e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24b4528b4f79fe03373d527a11143242"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga24b4528b4f79fe03373d527a11143242">adi_uart_SubmitTxBuffer</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, void *const pBuffer, uint32_t const nBufSize, bool const bDMA)</td></tr>
<tr class="memdesc:ga24b4528b4f79fe03373d527a11143242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a "filled" buffer for transmitting data in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>. This function sets up the apropriate interrupts associated with the transaction and marks the buffer as submitted.  <a href="#ga24b4528b4f79fe03373d527a11143242">More...</a><br /></td></tr>
<tr class="separator:ga24b4528b4f79fe03373d527a11143242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46c5b11b70e27aa30f666f8b8b7636f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga46c5b11b70e27aa30f666f8b8b7636f1">adi_uart_SubmitRxBuffer</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, void *const pBuffer, uint32_t const nBufSize, bool const bDMA)</td></tr>
<tr class="memdesc:ga46c5b11b70e27aa30f666f8b8b7636f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an empty buffer for receiving the data in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>. This will set up the Rx channel for notification on incoming data using either the DMA or UART interrupts, as well as mark the buffer as submitted.  <a href="#ga46c5b11b70e27aa30f666f8b8b7636f1">More...</a><br /></td></tr>
<tr class="separator:ga46c5b11b70e27aa30f666f8b8b7636f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga921298264659437be51caf979ef2ca8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga921298264659437be51caf979ef2ca8f">adi_uart_GetTxBuffer</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, void **const ppBuffer, uint32_t *pHwError)</td></tr>
<tr class="memdesc:ga921298264659437be51caf979ef2ca8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer buffer ownership from the device back to the API if the data transmit has completed. Otherwise it will block until completion. This allows a nonblocking call to become blocking. This function is only called in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>.  <a href="#ga921298264659437be51caf979ef2ca8f">More...</a><br /></td></tr>
<tr class="separator:ga921298264659437be51caf979ef2ca8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32896442229336af8805693bf60067eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga32896442229336af8805693bf60067eb">adi_uart_GetRxBuffer</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, void **const ppBuffer, uint32_t *pHwError)</td></tr>
<tr class="memdesc:ga32896442229336af8805693bf60067eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer buffer ownership from the device back to the API if the data receive has completed. Otherwise it will block until completion. This allows a nonblocking call to become blocking. This function is only called in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>.  <a href="#ga32896442229336af8805693bf60067eb">More...</a><br /></td></tr>
<tr class="separator:ga32896442229336af8805693bf60067eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a908925bf8407d81079adb23f9bcfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga83a908925bf8407d81079adb23f9bcfb">adi_uart_IsTxBufferAvailable</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, bool *const pbAvailable)</td></tr>
<tr class="memdesc:ga83a908925bf8407d81079adb23f9bcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek function to know if an empty buffer is avilable.  <a href="#ga83a908925bf8407d81079adb23f9bcfb">More...</a><br /></td></tr>
<tr class="separator:ga83a908925bf8407d81079adb23f9bcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2d533bed5d426df2b6bfdafc5646a71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gac2d533bed5d426df2b6bfdafc5646a71">adi_uart_IsRxBufferAvailable</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, bool *const pbAvailable)</td></tr>
<tr class="memdesc:gac2d533bed5d426df2b6bfdafc5646a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek function to know if a filled buffer is available.  <a href="#gac2d533bed5d426df2b6bfdafc5646a71">More...</a><br /></td></tr>
<tr class="separator:gac2d533bed5d426df2b6bfdafc5646a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54e81fa367c1ac6b84dcc81c1e5699a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga54e81fa367c1ac6b84dcc81c1e5699a6">adi_uart_Write</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, void *const pBuffer, uint32_t const nBufSize, bool const bDMA, uint32_t *pHwError)</td></tr>
<tr class="memdesc:ga54e81fa367c1ac6b84dcc81c1e5699a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit the buffer for transmitting the data in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2da3a2dc8041b22696c8136086d4fb19d86">ADI_UART_DATA_TRANSFER_MODE_BLOCKING</a>. Call to this function will not return until the entire buffer is transmitted. Returns error if this function is called when device is operating in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>. i.e Function "adi_uart_SubmitTxBuffer()" is called and the transfer is not yet complete.  <a href="#ga54e81fa367c1ac6b84dcc81c1e5699a6">More...</a><br /></td></tr>
<tr class="separator:ga54e81fa367c1ac6b84dcc81c1e5699a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9679689265db3e41ae60c8035f3ebb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gaa9679689265db3e41ae60c8035f3ebb2">adi_uart_Read</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, void *const pBuffer, uint32_t const nBufSize, bool const bDMA, uint32_t *pHwError)</td></tr>
<tr class="memdesc:gaa9679689265db3e41ae60c8035f3ebb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit the buffer for reading the data in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2da3a2dc8041b22696c8136086d4fb19d86">ADI_UART_DATA_TRANSFER_MODE_BLOCKING</a>. Call to this function will not return until the entire buffer is filled up. Returns error if this function is called when device is operating in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>. i.e The function "adi_uart_SubmitRxBuffer()" is called when the transfer is not yet complete.  <a href="#gaa9679689265db3e41ae60c8035f3ebb2">More...</a><br /></td></tr>
<tr class="separator:gaa9679689265db3e41ae60c8035f3ebb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad14e7814a525a6f78484e57809cb8124"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gad14e7814a525a6f78484e57809cb8124">adi_uart_EnableLoopBack</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, bool const bEnable)</td></tr>
<tr class="memdesc:gad14e7814a525a6f78484e57809cb8124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable the loopback for the specified UART device.  <a href="#gad14e7814a525a6f78484e57809cb8124">More...</a><br /></td></tr>
<tr class="separator:gad14e7814a525a6f78484e57809cb8124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab13134c91867cd224ef322df378f3197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gab13134c91867cd224ef322df378f3197">adi_uart_EnableAutobaud</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, bool const bEnable, bool const bAutobaudCallbackMode)</td></tr>
<tr class="memdesc:gab13134c91867cd224ef322df378f3197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable UART autobaud detection as well as configures the device for autobaud detection.  <a href="#gab13134c91867cd224ef322df378f3197">More...</a><br /></td></tr>
<tr class="separator:gab13134c91867cd224ef322df378f3197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c01046453db5781ad748663fcf7a5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gaa0c01046453db5781ad748663fcf7a5f">adi_uart_SetRxFifoTriggerLevel</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, <a class="el" href="group___u_a_r_t___driver.html#ga2fb94b41733ea77f181272269270b4ad">ADI_UART_TRIG_LEVEL</a> const eTriglevel)</td></tr>
<tr class="memdesc:gaa0c01046453db5781ad748663fcf7a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the RX FIFO trigger level. This will be the amount of data in the FIFO that will trigger an interrupt.  <a href="#gaa0c01046453db5781ad748663fcf7a5f">More...</a><br /></td></tr>
<tr class="separator:gaa0c01046453db5781ad748663fcf7a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3f0bb7190df1fae929bafd7025b37df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gac3f0bb7190df1fae929bafd7025b37df">adi_uart_EnableFifo</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, bool const bEnable)</td></tr>
<tr class="memdesc:gac3f0bb7190df1fae929bafd7025b37df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables internal FIFO as to work in 16550 mode. This helps to minimize system overhead and maximize system efficiency.  <a href="#gac3f0bb7190df1fae929bafd7025b37df">More...</a><br /></td></tr>
<tr class="separator:gac3f0bb7190df1fae929bafd7025b37df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08aed3beb53ad9182191ccd00c80f5dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga08aed3beb53ad9182191ccd00c80f5dd">adi_uart_GetBaudRate</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, uint32_t *pnBaudRate, uint32_t *pAutobaudError)</td></tr>
<tr class="memdesc:ga08aed3beb53ad9182191ccd00c80f5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the baudrate of the UART device instance. This is used in the scenario when a callback has not been initialized. This allows the the API to know if autobaud is complete. If this returns a baudrate other than 0, it indicates that the autobaud completed, otherwise autobaud is still in progress.  <a href="#ga08aed3beb53ad9182191ccd00c80f5dd">More...</a><br /></td></tr>
<tr class="separator:ga08aed3beb53ad9182191ccd00c80f5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d2a77c185d748fbacbb20f47d95c599"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga4d2a77c185d748fbacbb20f47d95c599">adi_uart_ForceTxBreak</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, bool const bEnable)</td></tr>
<tr class="memdesc:ga4d2a77c185d748fbacbb20f47d95c599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the UART to send out a break signal.  <a href="#ga4d2a77c185d748fbacbb20f47d95c599">More...</a><br /></td></tr>
<tr class="separator:ga4d2a77c185d748fbacbb20f47d95c599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83902185023fb9e41fcdf9154d677cf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga83902185023fb9e41fcdf9154d677cf9">adi_uart_SetConfiguration</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, <a class="el" href="group___u_a_r_t___driver.html#gae2e6f5ede10c8bec7107367dc6573b5e">ADI_UART_PARITY</a> const eParity, <a class="el" href="group___u_a_r_t___driver.html#gacbcbcbfdaa9005b03d70e8d9c0541632">ADI_UART_STOPBITS</a> const eStopBits, <a class="el" href="group___u_a_r_t___driver.html#gaa1ff4613eed877339134f5eec212d564">ADI_UART_WORDLEN</a> const eWordLength)</td></tr>
<tr class="memdesc:ga83902185023fb9e41fcdf9154d677cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration of UART data.  <a href="#ga83902185023fb9e41fcdf9154d677cf9">More...</a><br /></td></tr>
<tr class="separator:ga83902185023fb9e41fcdf9154d677cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace64edd32c2305221ba2dabc949e1b81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gace64edd32c2305221ba2dabc949e1b81">adi_uart_ConfigBaudRate</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, uint16_t const nDivC, uint8_t const nDivM, uint16_t const nDivN, uint8_t const nOSR)</td></tr>
<tr class="memdesc:gace64edd32c2305221ba2dabc949e1b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set baudrate by configuring the fractional dividors.  <a href="#gace64edd32c2305221ba2dabc949e1b81">More...</a><br /></td></tr>
<tr class="separator:gace64edd32c2305221ba2dabc949e1b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac56e4eb232ae7118a50e0e0338c9f204"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gac56e4eb232ae7118a50e0e0338c9f204">adi_uart_FlushTxFifo</a> (<a class="el" href="group___u_a_r_t___driver.html#ga7e3e8bd6d22a548d8ca2d9512a81eca2">ADI_UART_CONST_HANDLE</a> const hDevice)</td></tr>
<tr class="memdesc:gac56e4eb232ae7118a50e0e0338c9f204"><td class="mdescLeft">&#160;</td><td class="mdescRight">To flush the TX FIFO.  <a href="#gac56e4eb232ae7118a50e0e0338c9f204">More...</a><br /></td></tr>
<tr class="separator:gac56e4eb232ae7118a50e0e0338c9f204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a1c1c062f3a774661e67663ea68dd81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga2a1c1c062f3a774661e67663ea68dd81">adi_uart_FlushRxFifo</a> (<a class="el" href="group___u_a_r_t___driver.html#ga7e3e8bd6d22a548d8ca2d9512a81eca2">ADI_UART_CONST_HANDLE</a> const hDevice)</td></tr>
<tr class="memdesc:ga2a1c1c062f3a774661e67663ea68dd81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the RX FIFO.  <a href="#ga2a1c1c062f3a774661e67663ea68dd81">More...</a><br /></td></tr>
<tr class="separator:ga2a1c1c062f3a774661e67663ea68dd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c475b2b713da53f103fc5fc1c7085d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga0c475b2b713da53f103fc5fc1c7085d1">adi_uart_FlushRxChannel</a> (<a class="el" href="group___u_a_r_t___driver.html#ga7e3e8bd6d22a548d8ca2d9512a81eca2">ADI_UART_CONST_HANDLE</a> const hDevice)</td></tr>
<tr class="memdesc:ga0c475b2b713da53f103fc5fc1c7085d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the Rx channel and disable interrupts. This will stop any buffers in flight and clear out any data that was in the RX holding register as well as the Rx fifo. Once this is done, in order to turn back on Rx interrupts, a new transaction will need to be started (<a class="el" href="group___u_a_r_t___driver.html#gaa9679689265db3e41ae60c8035f3ebb2" title="Submit the buffer for reading the data in ADI_UART_DATA_TRANSFER_MODE_BLOCKING. Call to this function...">adi_uart_Read()</a> or <a class="el" href="group___u_a_r_t___driver.html#ga46c5b11b70e27aa30f666f8b8b7636f1" title="Submit an empty buffer for receiving the data in ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING. This will set up the Rx channel for notification on incoming data using either the DMA or UART interrupts, as well as mark the buffer as submitted. ">adi_uart_SubmitRxBuffer()</a>).  <a href="#ga0c475b2b713da53f103fc5fc1c7085d1">More...</a><br /></td></tr>
<tr class="separator:ga0c475b2b713da53f103fc5fc1c7085d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1af3e4d2a752a29d69a3dfd9d2eaed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga1f1af3e4d2a752a29d69a3dfd9d2eaed">adi_uart_FlushTxChannel</a> (<a class="el" href="group___u_a_r_t___driver.html#ga7e3e8bd6d22a548d8ca2d9512a81eca2">ADI_UART_CONST_HANDLE</a> const hDevice)</td></tr>
<tr class="memdesc:ga1f1af3e4d2a752a29d69a3dfd9d2eaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the Tx channel and disable interrupts.This will stop any buffers in flight and clear out any data that was in the TX holding register. Any data in the TX shift register will still finish transmitting.  <a href="#ga1f1af3e4d2a752a29d69a3dfd9d2eaed">More...</a><br /></td></tr>
<tr class="separator:ga1f1af3e4d2a752a29d69a3dfd9d2eaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga801bf358ce3c3bd9cbd73a7ff208b35b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#ga801bf358ce3c3bd9cbd73a7ff208b35b">adi_uart_IsTxComplete</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, bool *const pbComplete)</td></tr>
<tr class="memdesc:ga801bf358ce3c3bd9cbd73a7ff208b35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to let the API know if all the data had been drained from the Tx shift registers.  <a href="#ga801bf358ce3c3bd9cbd73a7ff208b35b">More...</a><br /></td></tr>
<tr class="separator:ga801bf358ce3c3bd9cbd73a7ff208b35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad95e1ed77514e52dac3ef856e2fb8b89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___driver.html#gad95e1ed77514e52dac3ef856e2fb8b89">adi_uart_RegisterCallback</a> (<a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const hDevice, const ADI_CALLBACK pfCallback, void *const pCBParam)</td></tr>
<tr class="memdesc:gad95e1ed77514e52dac3ef856e2fb8b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registering a callback function.  <a href="#gad95e1ed77514e52dac3ef856e2fb8b89">More...</a><br /></td></tr>
<tr class="separator:gad95e1ed77514e52dac3ef856e2fb8b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>UART Driver. </p>
<dl class="section note"><dt>Note</dt><dd>The application must include <a class="el" href="adi__uart_8h_source.html" title="UART device driver global include file. ">drivers/uart/adi_uart.h</a> to use this driver </dd>
<dd>
This driver requires the DMA driver.The application must include the DMA driver sources to avoid link errors. </dd>
<dd>
This documentation presented here is API documentation only. The device drive user's guide, located in the Documents folder, explains how to use these APIs in an application. </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga3be96bbdc8dc0925104d423b1e2d4a24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3be96bbdc8dc0925104d423b1e2d4a24">&#9670;&nbsp;</a></span>ADI_UART_UNIDIR_MEMORY_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADI_UART_UNIDIR_MEMORY_SIZE&#160;&#160;&#160;(48u + (60u + ADI_SEM_SIZE))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Amount of memory(bytes) required by the UART device driver for operating unidirectionally(Either RX or TX). This memory is completely owned by the driver until the end of the operation. </p>

<p class="definition">Definition at line <a class="el" href="adi__uart_8h_source.html#l00076">76</a> of file <a class="el" href="adi__uart_8h_source.html">adi_uart.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="adi__uart_8c_source.html#l00315">adi_uart_Open()</a>.</p>

</div>
</div>
<a id="gaa64cf5eea242e232b91092933291997e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa64cf5eea242e232b91092933291997e">&#9670;&nbsp;</a></span>ADI_UART_BIDIR_MEMORY_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADI_UART_BIDIR_MEMORY_SIZE&#160;&#160;&#160;(48u + (60u + ADI_SEM_SIZE)*2u)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Amount of memory(bytes) required by the UART device driver for operating bidirectionally(Both RX and TX). This memory is completely owned by the driver until the end of the operation. </p>

<p class="definition">Definition at line <a class="el" href="adi__uart_8h_source.html#l00081">81</a> of file <a class="el" href="adi__uart_8h_source.html">adi_uart.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="adi__uart_8c_source.html#l00315">adi_uart_Open()</a>.</p>

</div>
</div>
<a id="ga7e01b4f3118ba363a6e6ddc6239bcb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e01b4f3118ba363a6e6ddc6239bcb86">&#9670;&nbsp;</a></span>ADI_UART_NUM_DEVICES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADI_UART_NUM_DEVICES&#160;&#160;&#160;(sizeof(uart_device_info)/sizeof(ADI_UART_DEVICE_INFO))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of UART devices available on the chip. </p>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l00204">204</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="adi__uart_8c_source.html#l00315">adi_uart_Open()</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga13d69dc9cf05cd8e6f2983db6d7b99bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13d69dc9cf05cd8e6f2983db6d7b99bf">&#9670;&nbsp;</a></span>ADI_UART_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _ADI_UART_DEVICE* <a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle for managing the UART device typedef. </p>

<p class="definition">Definition at line <a class="el" href="adi__uart_8h_source.html#l00086">86</a> of file <a class="el" href="adi__uart_8h_source.html">adi_uart.h</a>.</p>

</div>
</div>
<a id="ga7e3e8bd6d22a548d8ca2d9512a81eca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e3e8bd6d22a548d8ca2d9512a81eca2">&#9670;&nbsp;</a></span>ADI_UART_CONST_HANDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const struct _ADI_UART_DEVICE* <a class="el" href="group___u_a_r_t___driver.html#ga7e3e8bd6d22a548d8ca2d9512a81eca2">ADI_UART_CONST_HANDLE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle for managing the UART device typedef 'const' version. </p>

<p class="definition">Definition at line <a class="el" href="adi__uart_8h_source.html#l00091">91</a> of file <a class="el" href="adi__uart_8h_source.html">adi_uart.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gafba0edfc161e68df641d6d9aa29d9592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafba0edfc161e68df641d6d9aa29d9592">&#9670;&nbsp;</a></span>ADI_UART_DIRECTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___driver.html#gafba0edfc161e68df641d6d9aa29d9592">ADI_UART_DIRECTION</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration for the UART direction. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafba0edfc161e68df641d6d9aa29d9592aec0a24292b639687f3d072aa42c3c7be"></a>ADI_UART_DIR_TRANSMIT&#160;</td><td class="fielddoc"><p>UART is only transmitting. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafba0edfc161e68df641d6d9aa29d9592a3f08f517a5b5d7f3d1ff528c6cf0825f"></a>ADI_UART_DIR_RECEIVE&#160;</td><td class="fielddoc"><p>UART is only receiving. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafba0edfc161e68df641d6d9aa29d9592acedb60591f41cca300937c47625ee6e2"></a>ADI_UART_DIR_BIDIRECTION&#160;</td><td class="fielddoc"><p>UART in bidirectional. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="adi__uart_8h_source.html#l00098">98</a> of file <a class="el" href="adi__uart_8h_source.html">adi_uart.h</a>.</p>

</div>
</div>
<a id="gad15ce602aed9ffcf2cd582c20063681e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad15ce602aed9ffcf2cd582c20063681e">&#9670;&nbsp;</a></span>ADI_UART_EVENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___driver.html#gad15ce602aed9ffcf2cd582c20063681e">ADI_UART_EVENT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration of events notified in the application provided callback. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad15ce602aed9ffcf2cd582c20063681ea146a079fc37b9d05b2387ae6900699be"></a>ADI_UART_EVENT_RX_BUFFER_PROCESSED&#160;</td><td class="fielddoc"><p>Rx buffer is processed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad15ce602aed9ffcf2cd582c20063681ea3b48fc09131e9ae59e2cf69b4969efea"></a>ADI_UART_EVENT_TX_BUFFER_PROCESSED&#160;</td><td class="fielddoc"><p>Tx buffer is processed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad15ce602aed9ffcf2cd582c20063681eaac9ba794e8cb2414b08dda670a0a60a0"></a>ADI_UART_EVENT_NO_RX_BUFFER_EVENT&#160;</td><td class="fielddoc"><p>No Rx buffer but data is in FIFO. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad15ce602aed9ffcf2cd582c20063681eaf402ac6e2bf17e5f8c0a2c7e6617bcfd"></a>ADI_UART_EVENT_AUTOBAUD_COMPLETE&#160;</td><td class="fielddoc"><p>Autobaud is complete. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad15ce602aed9ffcf2cd582c20063681ea4a3eef2ee79b3a80ce717c878c8c71e2"></a>ADI_UART_EVENT_HW_ERROR_DETECTED&#160;</td><td class="fielddoc"><p>Hardware error detected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad15ce602aed9ffcf2cd582c20063681ea2736950d6c87b60ce501de07f479bd25"></a>ADI_UART_EVENT_AUTOBAUD_ERROR_DETECTED&#160;</td><td class="fielddoc"><p>Autobaud error detected. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="adi__uart_8h_source.html#l00114">114</a> of file <a class="el" href="adi__uart_8h_source.html">adi_uart.h</a>.</p>

</div>
</div>
<a id="ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">&#9670;&nbsp;</a></span>ADI_UART_RESULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration for result code returned from the UART device driver functions. The return value of all UART APIs returning <a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> should always be tested at the application level for success or failure. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07"></a>ADI_UART_SUCCESS&#160;</td><td class="fielddoc"><p>Generic success. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5faa34dee86e0fd8ff9d79d7003ad526fb7"></a>ADI_UART_FAILED&#160;</td><td class="fielddoc"><p>Generic failure. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fad2b401b149870f9574592dcc4f101df6"></a>ADI_UART_SEMAPHORE_FAILED&#160;</td><td class="fielddoc"><p>Semaphore error. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0"></a>ADI_UART_INVALID_HANDLE&#160;</td><td class="fielddoc"><p>Invalid device handle. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8f3f6a7234347e32da9ca6d930ac0ccc"></a>ADI_UART_DEVICE_IN_USE&#160;</td><td class="fielddoc"><p>UART device in use. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa0b182e30b8cc33f9fc68fff65f96652a"></a>ADI_UART_INVALID_DEVICE_NUM&#160;</td><td class="fielddoc"><p>Invalid device number. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa7253178a162a39ffb233ea81ef2fa39b"></a>ADI_UART_INVALID_POINTER&#160;</td><td class="fielddoc"><p>NULL data pointer is not allowed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa51f399a08107be4ff84a7648b707f412"></a>ADI_UART_INSUFFICIENT_MEMORY&#160;</td><td class="fielddoc"><p>Insufficent memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa415f5f27395dad338cacb55962096bc6"></a>ADI_UART_INVALID_DIR&#160;</td><td class="fielddoc"><p>Invalid UART direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fabc85e74a4c980b2ccb7f94b77a957a12"></a>ADI_UART_OPERATION_NOT_ALLOWED&#160;</td><td class="fielddoc"><p>Invalid operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa083eb7765d831faf8044f38e277c32db"></a>ADI_UART_INVALID_PARAMETER&#160;</td><td class="fielddoc"><p>Invalid parameter. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5faa12d45c9dbdd6e4cf1bd90eeefb186aa"></a>ADI_UART_BUFFER_NOT_SUBMITTED&#160;</td><td class="fielddoc"><p>Buffer not submitted. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa04eb6c3ba9e76fd05eaaec82b678007a"></a>ADI_UART_INVALID_DATA_TRANSFER_MODE&#160;</td><td class="fielddoc"><p>Invalid transfer mode. Adi_uart_Read()/adi_uart_Write() is used in nonblocking mode or <a class="el" href="group___u_a_r_t___driver.html#ga46c5b11b70e27aa30f666f8b8b7636f1" title="Submit an empty buffer for receiving the data in ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING. This will set up the Rx channel for notification on incoming data using either the DMA or UART interrupts, as well as mark the buffer as submitted. ">adi_uart_SubmitRxBuffer()</a>/adi_uart_SubmitTxBuffer() is used in blocking mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8bf916459d0dc6423ba1ef87206269b2"></a>ADI_UART_HW_ERROR_DETECTED&#160;</td><td class="fielddoc"><p>Hardware error detected. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa7ee065f9a049969ec1d1d0d0ff99c8d8"></a>ADI_UART_AUTOBAUD_ERROR_DETECTED&#160;</td><td class="fielddoc"><p>Autobaud error detected. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa461e669f6f57cf6bb98da03ce1f81b03"></a>ADI_UART_ERR_DMA_REGISTER&#160;</td><td class="fielddoc"><p>Error while registering the DMA callback. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e56dc2cd0ac9eadf2fb4f8f48d90e5faa622d62095733a4e1252dc8c6a47c74d"></a>ADI_UART_INVALID_DATA_SIZE&#160;</td><td class="fielddoc"><p>Invalid transfer size. Must be less than 1025 bytes </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="adi__uart_8h_source.html#l00138">138</a> of file <a class="el" href="adi__uart_8h_source.html">adi_uart.h</a>.</p>

</div>
</div>
<a id="gaeaa3aec3854176b7894b5ff9cd2a1bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaa3aec3854176b7894b5ff9cd2a1bac">&#9670;&nbsp;</a></span>ADI_UART_HW_ERRORS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___driver.html#gaeaa3aec3854176b7894b5ff9cd2a1bac">ADI_UART_HW_ERRORS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration for UART hardware errors. If hardware error(s) occur in either callback or interrupt mode, they are mapped to <a class="el" href="group___u_a_r_t___driver.html#gaeaa3aec3854176b7894b5ff9cd2a1bac">ADI_UART_HW_ERRORS</a>. Interpretation of the break condition is application specific. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaeaa3aec3854176b7894b5ff9cd2a1baca7b1a85cc04ca252795b80f8372d1ae26"></a>ADI_UART_NO_HW_ERROR&#160;</td><td class="fielddoc"><p>No hardware error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeaa3aec3854176b7894b5ff9cd2a1bacaf91a4f5aec80730327607e0beb3a7521"></a>ADI_UART_HW_ERR_FRAMING&#160;</td><td class="fielddoc"><p>Rx framing error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeaa3aec3854176b7894b5ff9cd2a1baca34e1639df91bcf3bceae7448f478a973"></a>ADI_UART_HW_ERR_PARITY&#160;</td><td class="fielddoc"><p>Rx parity error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeaa3aec3854176b7894b5ff9cd2a1baca0ac969cc75d87070bc5e0857479c8b03"></a>ADI_UART_HW_ERR_OVERRUN&#160;</td><td class="fielddoc"><p>Receive overrun. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeaa3aec3854176b7894b5ff9cd2a1baca4fc610504a6c53fb59c71b749aecc29e"></a>ADI_UART_BREAK_INTERRUPT&#160;</td><td class="fielddoc"><p>Break condition. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeaa3aec3854176b7894b5ff9cd2a1bacacf52074c9b493e96d27fd7f3e87b9b78"></a>ADI_UART_HW_ERR_RX_CHAN_DMA_BUS_FAULT&#160;</td><td class="fielddoc"><p>Rx DMA channel bus fault detected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeaa3aec3854176b7894b5ff9cd2a1baca7c6b7e3e7116427cad90ece7cd42343e"></a>ADI_UART_HW_ERR_TX_CHAN_DMA_BUS_FAULT&#160;</td><td class="fielddoc"><p>Tx DMA channel bus fault detected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeaa3aec3854176b7894b5ff9cd2a1bacae910ac56187cc7d28a475d5d2c6d5a42"></a>ADI_UART_HW_ERR_RX_CHAN_DMA_INVALID_DESCR&#160;</td><td class="fielddoc"><p>Rx DMA channel invalid descriptor detected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeaa3aec3854176b7894b5ff9cd2a1baca543ccb381b7523f4d023340a79a3e821"></a>ADI_UART_HW_ERR_TX_CHAN_DMA_INVALID_DESCR&#160;</td><td class="fielddoc"><p>Tx DMA channel invalid descriptor detected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeaa3aec3854176b7894b5ff9cd2a1baca6dc27715f88fbfd4890c1fb006687e64"></a>ADI_UART_HW_ERR_RX_CHAN_DMA_UNKNOWN_ERROR&#160;</td><td class="fielddoc"><p>Rx DMA channel unknown error detected. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaeaa3aec3854176b7894b5ff9cd2a1baca72ee1cfe67ebef716e24fa6d76491c8f"></a>ADI_UART_HW_ERR_TX_CHAN_DMA_UNKNOWN_ERROR&#160;</td><td class="fielddoc"><p>Tx DMA channel unknown error detected. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="adi__uart_8h_source.html#l00187">187</a> of file <a class="el" href="adi__uart_8h_source.html">adi_uart.h</a>.</p>

</div>
</div>
<a id="gadec96e2e7c28bce540071f68d511b860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadec96e2e7c28bce540071f68d511b860">&#9670;&nbsp;</a></span>ADI_UART_AUTOBAUD_ERRORS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___driver.html#gadec96e2e7c28bce540071f68d511b860">ADI_UART_AUTOBAUD_ERRORS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration for UART autobaud errors. If autobaud related error(s) occur they are mapped to <a class="el" href="group___u_a_r_t___driver.html#gadec96e2e7c28bce540071f68d511b860">ADI_UART_AUTOBAUD_ERRORS</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadec96e2e7c28bce540071f68d511b860af15ba3e093a43c3f5f81ab4b8b64046a"></a>ADI_UART_AUTOBAUD_NO_ERROR&#160;</td><td class="fielddoc"><p>No autobaud error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadec96e2e7c28bce540071f68d511b860a03768ff672a2a2f029bd53f4f741f47a"></a>ADI_UART_AUTOBAUD_TIMEOUT_NO_START_EDGE&#160;</td><td class="fielddoc"><p>Timeout due to no valid start edge found during autobaud. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadec96e2e7c28bce540071f68d511b860a503620a32fb73759090bb04e6cd49131"></a>ADI_UART_AUTOBAUD_TIMEOUT_LONGBREAK&#160;</td><td class="fielddoc"><p>Timeout due to break condition detected during autobaud. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadec96e2e7c28bce540071f68d511b860a496f8fc4a183b08441962ef8dc16d06b"></a>ADI_UART_AUTOBAUD_TIMEOUT_NO_END_EDGE&#160;</td><td class="fielddoc"><p>Timeout due to no valid end edge found during autobaud. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="adi__uart_8h_source.html#l00219">219</a> of file <a class="el" href="adi__uart_8h_source.html">adi_uart.h</a>.</p>

</div>
</div>
<a id="ga2fb94b41733ea77f181272269270b4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fb94b41733ea77f181272269270b4ad">&#9670;&nbsp;</a></span>ADI_UART_TRIG_LEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___driver.html#ga2fb94b41733ea77f181272269270b4ad">ADI_UART_TRIG_LEVEL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration for the FIFO trigger level. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2fb94b41733ea77f181272269270b4adaf8428503b48904789431051048f23b91"></a>ADI_UART_RX_FIFO_TRIG_LEVEL_1BYTE&#160;</td><td class="fielddoc"><p>1-byte to trigger RX interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2fb94b41733ea77f181272269270b4ada3c5108fa222ab6447f6f468e9e1f2ed7"></a>ADI_UART_RX_FIFO_TRIG_LEVEL_4BYTE&#160;</td><td class="fielddoc"><p>4-byte to trigger RX interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2fb94b41733ea77f181272269270b4adaa949bdc96833e16df5b7fa2044359acd"></a>ADI_UART_RX_FIFO_TRIG_LEVEL_8BYTE&#160;</td><td class="fielddoc"><p>8-byte to trigger RX interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2fb94b41733ea77f181272269270b4ada04d4a09e05346e0fbf28901c64f84d16"></a>ADI_UART_RX_FIFO_TRIG_LEVEL_14BYTE&#160;</td><td class="fielddoc"><p>14-byte to trigger RX interrupt. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="adi__uart_8h_source.html#l00236">236</a> of file <a class="el" href="adi__uart_8h_source.html">adi_uart.h</a>.</p>

</div>
</div>
<a id="gaa1ff4613eed877339134f5eec212d564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1ff4613eed877339134f5eec212d564">&#9670;&nbsp;</a></span>ADI_UART_WORDLEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___driver.html#gaa1ff4613eed877339134f5eec212d564">ADI_UART_WORDLEN</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration for data width. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa1ff4613eed877339134f5eec212d564a82b39b883aee0b5388e990dbe00402d2"></a>ADI_UART_WORDLEN_5BITS&#160;</td><td class="fielddoc"><p>5 bits wide. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1ff4613eed877339134f5eec212d564a9de3e93f0b23243096c278572932e829"></a>ADI_UART_WORDLEN_6BITS&#160;</td><td class="fielddoc"><p>6 bits wide. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1ff4613eed877339134f5eec212d564a2df785631993a83e6bd8f9ed73836944"></a>ADI_UART_WORDLEN_7BITS&#160;</td><td class="fielddoc"><p>7 bits wide. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa1ff4613eed877339134f5eec212d564a78a8e22f2b0fbe6a40ac58468cb4eb0e"></a>ADI_UART_WORDLEN_8BITS&#160;</td><td class="fielddoc"><p>8 bits wide. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="adi__uart_8h_source.html#l00254">254</a> of file <a class="el" href="adi__uart_8h_source.html">adi_uart.h</a>.</p>

</div>
</div>
<a id="gae2e6f5ede10c8bec7107367dc6573b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2e6f5ede10c8bec7107367dc6573b5e">&#9670;&nbsp;</a></span>ADI_UART_PARITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___driver.html#gae2e6f5ede10c8bec7107367dc6573b5e">ADI_UART_PARITY</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration for parity check. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae2e6f5ede10c8bec7107367dc6573b5ea0b6bb5e0bf17133455f5082ac6415576"></a>ADI_UART_NO_PARITY&#160;</td><td class="fielddoc"><p>No parity. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae2e6f5ede10c8bec7107367dc6573b5eadaf71abda390a58cefc9495ddcb98a4a"></a>ADI_UART_ODD_PARITY&#160;</td><td class="fielddoc"><p>Odd parity. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae2e6f5ede10c8bec7107367dc6573b5eac04e39137eeab046c0adcee5f359c035"></a>ADI_UART_EVEN_PARITY&#160;</td><td class="fielddoc"><p>Even Parity. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae2e6f5ede10c8bec7107367dc6573b5ea713a4d91d53300b0edd72cd258f1e178"></a>ADI_UART_ODD_PARITY_STICKY&#160;</td><td class="fielddoc"><p>Sticky odd parity. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae2e6f5ede10c8bec7107367dc6573b5ea1366e213450367786a2d7de690fd4f75"></a>ADI_UART_EVEN_PARITY_STICKY&#160;</td><td class="fielddoc"><p>Sticky even parity. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="adi__uart_8h_source.html#l00271">271</a> of file <a class="el" href="adi__uart_8h_source.html">adi_uart.h</a>.</p>

</div>
</div>
<a id="gacbcbcbfdaa9005b03d70e8d9c0541632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbcbcbfdaa9005b03d70e8d9c0541632">&#9670;&nbsp;</a></span>ADI_UART_STOPBITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___driver.html#gacbcbcbfdaa9005b03d70e8d9c0541632">ADI_UART_STOPBITS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration for the number of stop bits. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacbcbcbfdaa9005b03d70e8d9c0541632a3545d5104bf8ca48d2a0408712172803"></a>ADI_UART_ONE_AND_HALF_TWO_STOPBITS&#160;</td><td class="fielddoc"><p>One stop bit regardless of the word length </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="adi__uart_8h_source.html#l00290">290</a> of file <a class="el" href="adi__uart_8h_source.html">adi_uart.h</a>.</p>

</div>
</div>
<a id="ga0185ba282c0f907f5a240b7e718e7f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0185ba282c0f907f5a240b7e718e7f2d">&#9670;&nbsp;</a></span>ADI_UART_TRANSFER_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_a_r_t___driver.html#ga0185ba282c0f907f5a240b7e718e7f2d">ADI_UART_TRANSFER_MODE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumeration for data transfer mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0185ba282c0f907f5a240b7e718e7f2da3a2dc8041b22696c8136086d4fb19d86"></a>ADI_UART_DATA_TRANSFER_MODE_BLOCKING&#160;</td><td class="fielddoc"><p>Mode of data transfer is not selected. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84"></a>ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING&#160;</td><td class="fielddoc"><p>Blocking mode. Only calls to adi_uart_Read or adi_uart_write are allowed for sending or receiving data.</p>
<p>Non-Blocking mode. Only calls to adi_uart_SubmitRxBuffer or adi_uart_SubmitTxBuffer are allowed for sending or receiving data. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="adi__uart_8h_source.html#l00305">305</a> of file <a class="el" href="adi__uart_8h_source.html">adi_uart.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa0237738e853bd3e25835d7037ed5a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0237738e853bd3e25835d7037ed5a58">&#9670;&nbsp;</a></span>adi_uart_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_Open </td>
          <td>(</td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>nDeviceNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#gafba0edfc161e68df641d6d9aa29d9592">ADI_UART_DIRECTION</a> const&#160;</td>
          <td class="paramname"><em>eDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pMemory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>nMemSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> *const&#160;</td>
          <td class="paramname"><em>phDevice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization function for the UART device. </p>
<p>Opens the specified UART device. This function must be called before operating any UART device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nDeviceNum</td><td>UART device instance to be opened. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eDirection</td><td>Direction of the UART operation. (i.e Rx or Tx) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMemory</td><td>Pointer to a 32 bit aligned buffer the size of <a class="el" href="group___u_a_r_t___driver.html#ga3be96bbdc8dc0925104d423b1e2d4a24">ADI_UART_UNIDIR_MEMORY_SIZE</a> or <a class="el" href="group___u_a_r_t___driver.html#gaa64cf5eea242e232b91092933291997e">ADI_UART_BIDIR_MEMORY_SIZE</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nMemSize</td><td>Size of the buffer to which "pMemory" points. This will vary based on direction of operation for this device instance. (i.e Rx and Tx, Rx, Tx)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">phDevice</td><td>The caller's device handle pointer for storing the initialized device instance data pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully initialized UART device.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fad2b401b149870f9574592dcc4f101df6">ADI_UART_SEMAPHORE_FAILED</a> Failed to create semaphore.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa0b182e30b8cc33f9fc68fff65f96652a">ADI_UART_INVALID_DEVICE_NUM</a> [D] Device instance is invalid.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa51f399a08107be4ff84a7648b707f412">ADI_UART_INSUFFICIENT_MEMORY</a> [D] Supplied memory is insufficient for the operation of specified UART device.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8f3f6a7234347e32da9ca6d930ac0ccc">ADI_UART_DEVICE_IN_USE</a> [D] Device is already open.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gae0f32765fc758abec4b444a9d5a709e2" title="Uninitialize the memory for the specified UART instance. ">adi_uart_Close()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>: Memory supplied by the API will be used by the driver for managing the UART device. This memory can be reused once device is closed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l00315">315</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="gae0f32765fc758abec4b444a9d5a709e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0f32765fc758abec4b444a9d5a709e2">&#9670;&nbsp;</a></span>adi_uart_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uninitialize the memory for the specified UART instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>UART device handle whose operation is to be closed. This handle was obtained when the UART device instance was opened successfully.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully closed the UART device instance.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fad2b401b149870f9574592dcc4f101df6">ADI_UART_SEMAPHORE_FAILED</a> Failed to delete the semaphore.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] Invalid UART device handle.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8f3f6a7234347e32da9ca6d930ac0ccc">ADI_UART_DEVICE_IN_USE</a> [D] Specified UART device is in the process of a transaction or autobaud has not completed.</li>
</ul>
</dd></dl>
<p>Closes the operation of specified UART device. Device needs to be opened again for any further use.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>: It is the user's responsibility to free/reuse the memory supplied during the opening of the device. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l00507">507</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="ga24b4528b4f79fe03373d527a11143242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24b4528b4f79fe03373d527a11143242">&#9670;&nbsp;</a></span>adi_uart_SubmitTxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_SubmitTxBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>nBufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>bDMA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a "filled" buffer for transmitting data in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>. This function sets up the apropriate interrupts associated with the transaction and marks the buffer as submitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Pointer to data supplied by the API that is to be transmitted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBufSize</td><td>Size of the buffer to be transmitted(in bytes). Must be smaller than 1024 bytes for DMA transfers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bDMA</td><td>Submit the buffer using the DMA flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully submitted the buffer for transmission.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5faa34dee86e0fd8ff9d79d7003ad526fb7">ADI_UART_FAILED</a> [D] Generic failure. In this case the size of the data buffer we are trying to submit is NULL.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa04eb6c3ba9e76fd05eaaec82b678007a">ADI_UART_INVALID_DATA_TRANSFER_MODE</a> [D] Device is operating in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2da3a2dc8041b22696c8136086d4fb19d86">ADI_UART_DATA_TRANSFER_MODE_BLOCKING</a>. This operation is only allowed in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] Invalid UART device handle.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fabc85e74a4c980b2ccb7f94b77a957a12">ADI_UART_OPERATION_NOT_ALLOWED</a> [D] Device direction is set up as <a class="el" href="group___u_a_r_t___driver.html#ggafba0edfc161e68df641d6d9aa29d9592a3f08f517a5b5d7f3d1ff528c6cf0825f">ADI_UART_DIR_RECEIVE</a>, so we can not complete a transmit operation. The required directions are <a class="el" href="group___u_a_r_t___driver.html#ggafba0edfc161e68df641d6d9aa29d9592aec0a24292b639687f3d072aa42c3c7be">ADI_UART_DIR_TRANSMIT</a> or <a class="el" href="group___u_a_r_t___driver.html#ggafba0edfc161e68df641d6d9aa29d9592acedb60591f41cca300937c47625ee6e2">ADI_UART_DIR_BIDIRECTION</a>.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa7253178a162a39ffb233ea81ef2fa39b">ADI_UART_INVALID_POINTER</a> [D] Pointer to the buffer being submitted is NULL.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8f3f6a7234347e32da9ca6d930ac0ccc">ADI_UART_DEVICE_IN_USE</a> [D] Autobaud in progress.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5faa622d62095733a4e1252dc8c6a47c74d">ADI_UART_INVALID_DATA_SIZE</a> [D] DMA transfers must be smaller than 1025 bytes.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga83a908925bf8407d81079adb23f9bcfb" title="Peek function to know if an empty buffer is avilable. ">adi_uart_IsTxBufferAvailable()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga921298264659437be51caf979ef2ca8f" title="Transfer buffer ownership from the device back to the API if the data transmit has completed...">adi_uart_GetTxBuffer()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga46c5b11b70e27aa30f666f8b8b7636f1" title="Submit an empty buffer for receiving the data in ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING. This will set up the Rx channel for notification on incoming data using either the DMA or UART interrupts, as well as mark the buffer as submitted. ">adi_uart_SubmitRxBuffer()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>: Only one transfer mode (DMA vs. PIO) can be used at once. For example, if you submit a buffer in PIO mode and then right away another using the DMA, this transaction will be denied. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l00594">594</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="ga46c5b11b70e27aa30f666f8b8b7636f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46c5b11b70e27aa30f666f8b8b7636f1">&#9670;&nbsp;</a></span>adi_uart_SubmitRxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_SubmitRxBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>nBufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>bDMA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit an empty buffer for receiving the data in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>. This will set up the Rx channel for notification on incoming data using either the DMA or UART interrupts, as well as mark the buffer as submitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Pointer to buffer from that will be filled by the driver when data has been received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBufSize</td><td>Size of the buffer(in bytes). Must be smaller than 1024 bytes for DMA transfers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bDMA</td><td>Submit the buffer using DMA flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully submitted the buffer for receiving data.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5faa34dee86e0fd8ff9d79d7003ad526fb7">ADI_UART_FAILED</a> [D] Generic failure. In this case the size of the data buffer we are trying to submit is NULL.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa04eb6c3ba9e76fd05eaaec82b678007a">ADI_UART_INVALID_DATA_TRANSFER_MODE</a> [D] Device is operating in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2da3a2dc8041b22696c8136086d4fb19d86">ADI_UART_DATA_TRANSFER_MODE_BLOCKING</a>. This operation is only allowed in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] Invalid UART device handle.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fabc85e74a4c980b2ccb7f94b77a957a12">ADI_UART_OPERATION_NOT_ALLOWED</a> [D] Device direction is set up as <a class="el" href="group___u_a_r_t___driver.html#ggafba0edfc161e68df641d6d9aa29d9592aec0a24292b639687f3d072aa42c3c7be">ADI_UART_DIR_TRANSMIT</a>, so we can not complete a receive operation. The required directions are <a class="el" href="group___u_a_r_t___driver.html#ggafba0edfc161e68df641d6d9aa29d9592a3f08f517a5b5d7f3d1ff528c6cf0825f">ADI_UART_DIR_RECEIVE</a> or <a class="el" href="group___u_a_r_t___driver.html#ggafba0edfc161e68df641d6d9aa29d9592acedb60591f41cca300937c47625ee6e2">ADI_UART_DIR_BIDIRECTION</a>.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa7253178a162a39ffb233ea81ef2fa39b">ADI_UART_INVALID_POINTER</a> [D] Pointer to the buffer being submitted is NULL.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8f3f6a7234347e32da9ca6d930ac0ccc">ADI_UART_DEVICE_IN_USE</a> [D] Autobaud in progress.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5faa622d62095733a4e1252dc8c6a47c74d">ADI_UART_INVALID_DATA_SIZE</a> [D] DMA transfers must be smaller than 1025 bytes.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gac2d533bed5d426df2b6bfdafc5646a71" title="Peek function to know if a filled buffer is available. ">adi_uart_IsRxBufferAvailable()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga32896442229336af8805693bf60067eb" title="Transfer buffer ownership from the device back to the API if the data receive has completed...">adi_uart_GetRxBuffer()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga24b4528b4f79fe03373d527a11143242" title="Submit a &quot;filled&quot; buffer for transmitting data in ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING. This function sets up the apropriate interrupts associated with the transaction and marks the buffer as submitted. ">adi_uart_SubmitTxBuffer()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>: Only one transfer mode (DMA vs. PIO) can be used at once. For example, if you submit a buffer in PIO mode and then right away another using the DMA, this transaction will be denied. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l00784">784</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="ga921298264659437be51caf979ef2ca8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga921298264659437be51caf979ef2ca8f">&#9670;&nbsp;</a></span>adi_uart_GetTxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_GetTxBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **const&#160;</td>
          <td class="paramname"><em>ppBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pHwError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer buffer ownership from the device back to the API if the data transmit has completed. Otherwise it will block until completion. This allows a nonblocking call to become blocking. This function is only called in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ppBuffer</td><td>Contains the address of the buffer passed down from the API for transmitting data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pHwError</td><td>Pointer to an integer that correlates with <a class="el" href="group___u_a_r_t___driver.html#gaeaa3aec3854176b7894b5ff9cd2a1bac">ADI_UART_HW_ERRORS</a>, containg the hardware status. If there is no hardware event, this will be 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully returned buffer to the API.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8bf916459d0dc6423ba1ef87206269b2">ADI_UART_HW_ERROR_DETECTED</a> Hardware error(s) detected. "pHwError" can be checked for the specific error code(s).</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fabc85e74a4c980b2ccb7f94b77a957a12">ADI_UART_OPERATION_NOT_ALLOWED</a> [D] Call to this function is not allowed in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2da3a2dc8041b22696c8136086d4fb19d86">ADI_UART_DATA_TRANSFER_MODE_BLOCKING</a>.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] Invalid UART device handle.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5faa12d45c9dbdd6e4cf1bd90eeefb186aa">ADI_UART_BUFFER_NOT_SUBMITTED</a> [D] The buffer has not been submitted to the driver.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga83a908925bf8407d81079adb23f9bcfb" title="Peek function to know if an empty buffer is avilable. ">adi_uart_IsTxBufferAvailable()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga24b4528b4f79fe03373d527a11143242" title="Submit a &quot;filled&quot; buffer for transmitting data in ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING. This function sets up the apropriate interrupts associated with the transaction and marks the buffer as submitted. ">adi_uart_SubmitTxBuffer()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>: If the transaction has already completed, this will return immediately rather than block. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l00970">970</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="ga32896442229336af8805693bf60067eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32896442229336af8805693bf60067eb">&#9670;&nbsp;</a></span>adi_uart_GetRxBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_GetRxBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **const&#160;</td>
          <td class="paramname"><em>ppBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pHwError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer buffer ownership from the device back to the API if the data receive has completed. Otherwise it will block until completion. This allows a nonblocking call to become blocking. This function is only called in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ppBuffer</td><td>Contains the address of the buffer passed down from the API for receiving data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pHwError</td><td>Pointer to an integer that correlates with <a class="el" href="group___u_a_r_t___driver.html#gaeaa3aec3854176b7894b5ff9cd2a1bac">ADI_UART_HW_ERRORS</a>, containg the hardware status. If there is no hardware event, this will be 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully returned buffer to the API.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8bf916459d0dc6423ba1ef87206269b2">ADI_UART_HW_ERROR_DETECTED</a> Hardware error(s) detected. "pHwError" can be checked for the specific error code(s).</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fabc85e74a4c980b2ccb7f94b77a957a12">ADI_UART_OPERATION_NOT_ALLOWED</a> [D] Call to this function is not allowed in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2da3a2dc8041b22696c8136086d4fb19d86">ADI_UART_DATA_TRANSFER_MODE_BLOCKING</a>.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] Invalid UART device handle.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5faa12d45c9dbdd6e4cf1bd90eeefb186aa">ADI_UART_BUFFER_NOT_SUBMITTED</a> [D] The buffer has not been submitted to the driver.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gac2d533bed5d426df2b6bfdafc5646a71" title="Peek function to know if a filled buffer is available. ">adi_uart_IsRxBufferAvailable()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga46c5b11b70e27aa30f666f8b8b7636f1" title="Submit an empty buffer for receiving the data in ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING. This will set up the Rx channel for notification on incoming data using either the DMA or UART interrupts, as well as mark the buffer as submitted. ">adi_uart_SubmitRxBuffer()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>: If the transaction has already completed, this will return immediately rather than block. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l01028">1028</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="ga83a908925bf8407d81079adb23f9bcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83a908925bf8407d81079adb23f9bcfb">&#9670;&nbsp;</a></span>adi_uart_IsTxBufferAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_IsTxBufferAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *const&#160;</td>
          <td class="paramname"><em>pbAvailable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peek function to know if an empty buffer is avilable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pbAvailable</td><td>Pointer to a boolean variable. Contains "true" if there is an empty buffer and a call to "adi_uart_GetTxBuffer" is ensured to be successful. Contains "false" if there is no empty buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully retrieved the status of availability of the buffer.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] Invalid UART device handle.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fabc85e74a4c980b2ccb7f94b77a957a12">ADI_UART_OPERATION_NOT_ALLOWED</a> [D] Call to this function is not allowed in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2da3a2dc8041b22696c8136086d4fb19d86">ADI_UART_DATA_TRANSFER_MODE_BLOCKING</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga921298264659437be51caf979ef2ca8f" title="Transfer buffer ownership from the device back to the API if the data transmit has completed...">adi_uart_GetTxBuffer()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#gac2d533bed5d426df2b6bfdafc5646a71" title="Peek function to know if a filled buffer is available. ">adi_uart_IsRxBufferAvailable</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l01481">1481</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="gac2d533bed5d426df2b6bfdafc5646a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2d533bed5d426df2b6bfdafc5646a71">&#9670;&nbsp;</a></span>adi_uart_IsRxBufferAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_IsRxBufferAvailable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *const&#160;</td>
          <td class="paramname"><em>pbAvailable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peek function to know if a filled buffer is available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pbAvailable</td><td>Pointer to a boolean variable. Contains "true" if there is an empty buffer and a call to "adi_uart_GetTxBuffer" is ensured to be successful. Contains "false" if there is no empty buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully retrieved the status of availability of the buffer.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] Invalid UART device handle.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fabc85e74a4c980b2ccb7f94b77a957a12">ADI_UART_OPERATION_NOT_ALLOWED</a> [D] Call to this function is not allowed in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2da3a2dc8041b22696c8136086d4fb19d86">ADI_UART_DATA_TRANSFER_MODE_BLOCKING</a>.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga32896442229336af8805693bf60067eb" title="Transfer buffer ownership from the device back to the API if the data receive has completed...">adi_uart_GetRxBuffer()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l01537">1537</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="ga54e81fa367c1ac6b84dcc81c1e5699a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54e81fa367c1ac6b84dcc81c1e5699a6">&#9670;&nbsp;</a></span>adi_uart_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>nBufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>bDMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pHwError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit the buffer for transmitting the data in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2da3a2dc8041b22696c8136086d4fb19d86">ADI_UART_DATA_TRANSFER_MODE_BLOCKING</a>. Call to this function will not return until the entire buffer is transmitted. Returns error if this function is called when device is operating in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>. i.e Function "adi_uart_SubmitTxBuffer()" is called and the transfer is not yet complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Pointer to data supplied by the API that is to be transmitted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBufSize</td><td>Size of the buffer(in bytes). Must be smaller than 1024 bytes for DMA transfers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bDMA</td><td>Submit the buffer using the DMA flag. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pHwError</td><td>Pointer to an integer that correlates with <a class="el" href="group___u_a_r_t___driver.html#gaeaa3aec3854176b7894b5ff9cd2a1bac">ADI_UART_HW_ERRORS</a>, containg the hardware status. If there is no hardware event, this will be 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully transmitted the data from the submitted buffer.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8bf916459d0dc6423ba1ef87206269b2">ADI_UART_HW_ERROR_DETECTED</a> Hardware error(s) detected. "pHwError" can be checked for the specific error code(s).</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5faa34dee86e0fd8ff9d79d7003ad526fb7">ADI_UART_FAILED</a> [D] Generic failure. In this case the size of the data buffer we are trying to submit is NULL.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa04eb6c3ba9e76fd05eaaec82b678007a">ADI_UART_INVALID_DATA_TRANSFER_MODE</a> [D] Device is operating in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>. This operation is only allowed in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2da3a2dc8041b22696c8136086d4fb19d86">ADI_UART_DATA_TRANSFER_MODE_BLOCKING</a>.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fabc85e74a4c980b2ccb7f94b77a957a12">ADI_UART_OPERATION_NOT_ALLOWED</a> [D] Device direction is set up as <a class="el" href="group___u_a_r_t___driver.html#ggafba0edfc161e68df641d6d9aa29d9592a3f08f517a5b5d7f3d1ff528c6cf0825f">ADI_UART_DIR_RECEIVE</a>, so we can not complete a transmit operation. The required directions are <a class="el" href="group___u_a_r_t___driver.html#ggafba0edfc161e68df641d6d9aa29d9592aec0a24292b639687f3d072aa42c3c7be">ADI_UART_DIR_TRANSMIT</a> or <a class="el" href="group___u_a_r_t___driver.html#ggafba0edfc161e68df641d6d9aa29d9592acedb60591f41cca300937c47625ee6e2">ADI_UART_DIR_BIDIRECTION</a>.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] Invalid UART device handle.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa7253178a162a39ffb233ea81ef2fa39b">ADI_UART_INVALID_POINTER</a> [D] The pointer to the buffer being submitted is a NULL.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8f3f6a7234347e32da9ca6d930ac0ccc">ADI_UART_DEVICE_IN_USE</a> [D] Autobaud in progress.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5faa622d62095733a4e1252dc8c6a47c74d">ADI_UART_INVALID_DATA_SIZE</a> [D] DMA transfers must be smaller than 1025 bytes.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#gaa9679689265db3e41ae60c8035f3ebb2" title="Submit the buffer for reading the data in ADI_UART_DATA_TRANSFER_MODE_BLOCKING. Call to this function...">adi_uart_Read()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga24b4528b4f79fe03373d527a11143242" title="Submit a &quot;filled&quot; buffer for transmitting data in ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING. This function sets up the apropriate interrupts associated with the transaction and marks the buffer as submitted. ">adi_uart_SubmitTxBuffer()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>: This function is a blocking function which means that the function returns only after the completion of buffer transmission. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l01166">1166</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="gaa9679689265db3e41ae60c8035f3ebb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9679689265db3e41ae60c8035f3ebb2">&#9670;&nbsp;</a></span>adi_uart_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>nBufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>bDMA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pHwError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit the buffer for reading the data in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2da3a2dc8041b22696c8136086d4fb19d86">ADI_UART_DATA_TRANSFER_MODE_BLOCKING</a>. Call to this function will not return until the entire buffer is filled up. Returns error if this function is called when device is operating in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>. i.e The function "adi_uart_SubmitRxBuffer()" is called when the transfer is not yet complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Pointer to buffer from that will be filled by the driver when data has been received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nBufSize</td><td>Size of the buffer(in bytes). Must be smaller than 1024 bytes for DMA transfers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bDMA</td><td>Submit the buffer using DMA flag. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pHwError</td><td>Pointer to an integer that correlates with <a class="el" href="group___u_a_r_t___driver.html#gaeaa3aec3854176b7894b5ff9cd2a1bac">ADI_UART_HW_ERRORS</a>, containg the hardware status. If there is no hardware event, this will be 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully submitted the buffer for receiving data.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8bf916459d0dc6423ba1ef87206269b2">ADI_UART_HW_ERROR_DETECTED</a> Hardware error(s) detected. "pHwError" can be checked for the specific error code(s).</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5faa34dee86e0fd8ff9d79d7003ad526fb7">ADI_UART_FAILED</a> [D] Generic failure. In this case the size of the data buffer we are trying to submit is NULL.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa04eb6c3ba9e76fd05eaaec82b678007a">ADI_UART_INVALID_DATA_TRANSFER_MODE</a> [D] Device is operating in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2dadee51c7c3b4cd44b2a1b61d667f50c84">ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING</a>. This operation is only allowed in <a class="el" href="group___u_a_r_t___driver.html#gga0185ba282c0f907f5a240b7e718e7f2da3a2dc8041b22696c8136086d4fb19d86">ADI_UART_DATA_TRANSFER_MODE_BLOCKING</a>.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] Invalid UART device handle.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fabc85e74a4c980b2ccb7f94b77a957a12">ADI_UART_OPERATION_NOT_ALLOWED</a> [D] Device direction is set up as <a class="el" href="group___u_a_r_t___driver.html#ggafba0edfc161e68df641d6d9aa29d9592aec0a24292b639687f3d072aa42c3c7be">ADI_UART_DIR_TRANSMIT</a>, so we can not complete a receive operation. The required directions are <a class="el" href="group___u_a_r_t___driver.html#ggafba0edfc161e68df641d6d9aa29d9592a3f08f517a5b5d7f3d1ff528c6cf0825f">ADI_UART_DIR_RECEIVE</a> or <a class="el" href="group___u_a_r_t___driver.html#ggafba0edfc161e68df641d6d9aa29d9592acedb60591f41cca300937c47625ee6e2">ADI_UART_DIR_BIDIRECTION</a>.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa7253178a162a39ffb233ea81ef2fa39b">ADI_UART_INVALID_POINTER</a> [D] Pointer to the buffer being submitted is NULL.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8f3f6a7234347e32da9ca6d930ac0ccc">ADI_UART_DEVICE_IN_USE</a> [D] Autobaud in progress.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5faa622d62095733a4e1252dc8c6a47c74d">ADI_UART_INVALID_DATA_SIZE</a> [D] DMA transfers must be smaller than 1025 bytes.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga54e81fa367c1ac6b84dcc81c1e5699a6" title="Submit the buffer for transmitting the data in ADI_UART_DATA_TRANSFER_MODE_BLOCKING. Call to this function will not return until the entire buffer is transmitted. Returns error if this function is called when device is operating in ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING. i.e Function &quot;adi_uart_SubmitTxBuffer()&quot; is called and the transfer is not yet complete. ">adi_uart_Write()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#ga24b4528b4f79fe03373d527a11143242" title="Submit a &quot;filled&quot; buffer for transmitting data in ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING. This function sets up the apropriate interrupts associated with the transaction and marks the buffer as submitted. ">adi_uart_SubmitTxBuffer()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>: This function is a blocking function which means that the function returns only after the completion of data receive. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l01298">1298</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="gad14e7814a525a6f78484e57809cb8124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad14e7814a525a6f78484e57809cb8124">&#9670;&nbsp;</a></span>adi_uart_EnableLoopBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_EnableLoopBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable the loopback for the specified UART device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bEnable</td><td>Boolean flag to indicate whether to enable or disable the loopback mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully enable/disable the loopback.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> Invalid UART device handle. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l01989">1989</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="gab13134c91867cd224ef322df378f3197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab13134c91867cd224ef322df378f3197">&#9670;&nbsp;</a></span>adi_uart_EnableAutobaud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_EnableAutobaud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>bEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>bAutobaudCallbackMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable UART autobaud detection as well as configures the device for autobaud detection. </p>
<p>The baud rate is detected using the hardware support. After the baud rate is detected the interrupt handler is notified of the completion. When a callback is not registered with UART driver, the API <a class="el" href="group___u_a_r_t___driver.html#ga08aed3beb53ad9182191ccd00c80f5dd" title="Get the baudrate of the UART device instance. This is used in the scenario when a callback has not be...">adi_uart_GetBaudRate()</a> can be used to know if autobaud is complete. Autobaud needs to be disabled in order to clear the internal counter and to close the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to UART device whose autobaud detection to be enabled/disabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bEnable</td><td>Boolean flag to indicate whether to enable or disable the autobaud. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bAutobaudCallbackMode</td><td>Use a callback to report autobaud errors or type <a class="el" href="group___u_a_r_t___driver.html#gadec96e2e7c28bce540071f68d511b860">ADI_UART_AUTOBAUD_ERRORS</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully enabled/disabled Autobaud detection.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8f3f6a7234347e32da9ca6d930ac0ccc">ADI_UART_DEVICE_IN_USE</a> [D] Trying to enable/disable Autobaud when dataflow is enabled or autobaud is in progress.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] Invalid UART device handle.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga08aed3beb53ad9182191ccd00c80f5dd" title="Get the baudrate of the UART device instance. This is used in the scenario when a callback has not be...">adi_uart_GetBaudRate()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>: For autobaud we assume the key character being used is a carrige return (0xD), so the start edge count is hardcoded to the second edge (first edge after start edge) and the last edge count is set to the fouth edge. This will give us a total bit count of 8 bits that we will time in order to figure out the baud rate (bits/second). </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l01878">1878</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="gaa0c01046453db5781ad748663fcf7a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0c01046453db5781ad748663fcf7a5f">&#9670;&nbsp;</a></span>adi_uart_SetRxFifoTriggerLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_SetRxFifoTriggerLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga2fb94b41733ea77f181272269270b4ad">ADI_UART_TRIG_LEVEL</a> const&#160;</td>
          <td class="paramname"><em>eTriglevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the RX FIFO trigger level. This will be the amount of data in the FIFO that will trigger an interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eTriglevel</td><td>Trigger level to be set in terms of number of bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully set the trigger level.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] The given UART handle is invalid. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l02028">2028</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="gac3f0bb7190df1fae929bafd7025b37df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3f0bb7190df1fae929bafd7025b37df">&#9670;&nbsp;</a></span>adi_uart_EnableFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_EnableFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables internal FIFO as to work in 16550 mode. This helps to minimize system overhead and maximize system efficiency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bEnable</td><td>Boolean flag to indicate whether to enable or disable FIFO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> If successfully enabled FIFO for UART device.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] The given UART handle is invalid. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l02063">2063</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="ga08aed3beb53ad9182191ccd00c80f5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08aed3beb53ad9182191ccd00c80f5dd">&#9670;&nbsp;</a></span>adi_uart_GetBaudRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_GetBaudRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pnBaudRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pAutobaudError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the baudrate of the UART device instance. This is used in the scenario when a callback has not been initialized. This allows the the API to know if autobaud is complete. If this returns a baudrate other than 0, it indicates that the autobaud completed, otherwise autobaud is still in progress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pnBaudRate</td><td>Pointer to a location where baudrate is to be written. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pAutobaudError</td><td>Pointer to an integer that will hold the value of any baudrate error(s), that correlates with <a class="el" href="group___u_a_r_t___driver.html#gadec96e2e7c28bce540071f68d511b860">ADI_UART_AUTOBAUD_ERRORS</a>. This will be 0 if there are no errors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully retrieved the baudrate.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa7ee065f9a049969ec1d1d0d0ff99c8d8">ADI_UART_AUTOBAUD_ERROR_DETECTED</a> There has been an autobaud error. The API can get the specific error(s) by checking "pAutobaudError".</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] Invalid UART device handle.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa7253178a162a39ffb233ea81ef2fa39b">ADI_UART_INVALID_POINTER</a> [D] The pointer to baudrate or autobaud error is NULL. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l01809">1809</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="ga4d2a77c185d748fbacbb20f47d95c599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d2a77c185d748fbacbb20f47d95c599">&#9670;&nbsp;</a></span>adi_uart_ForceTxBreak()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_ForceTxBreak </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>bEnable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces the UART to send out a break signal. </p>
<p>Sets the UART Tx pin to a logic-low/high (depending upon the Tx polarity) asynchronously. The UART keeps transmitting break until it is disabled to send the break.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Handle to the UART whose Tx is forced to send a break. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bEnable</td><td>Flag which indicates whether to enable or disable transmitting the break.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status</dd></dl>
<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> If successfully enabled or disabled sending break.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] If the given UART handle is invalid. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l01950">1950</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="ga83902185023fb9e41fcdf9154d677cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83902185023fb9e41fcdf9154d677cf9">&#9670;&nbsp;</a></span>adi_uart_SetConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_SetConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#gae2e6f5ede10c8bec7107367dc6573b5e">ADI_UART_PARITY</a> const&#160;</td>
          <td class="paramname"><em>eParity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#gacbcbcbfdaa9005b03d70e8d9c0541632">ADI_UART_STOPBITS</a> const&#160;</td>
          <td class="paramname"><em>eStopBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#gaa1ff4613eed877339134f5eec212d564">ADI_UART_WORDLEN</a> const&#160;</td>
          <td class="paramname"><em>eWordLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configuration of UART data. </p>
<p>Sets the configuration parameters for the specified UART device such as wordlength, whether to enable/disable the parity, and the number of stop bits. This function returns an error if the device has active data or autobaud is in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eParity</td><td>Specify the type of parity check for the UART device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eStopBits</td><td>Specify the stop-bits for the UART device. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eWordLength</td><td>Specify the word size of the data for the UART device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully set the data configuration.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8f3f6a7234347e32da9ca6d930ac0ccc">ADI_UART_DEVICE_IN_USE</a> [D] This operation is not allowed when a data transfer or autobaud is in progress.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] Invalid UART device handle. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l01689">1689</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="gace64edd32c2305221ba2dabc949e1b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace64edd32c2305221ba2dabc949e1b81">&#9670;&nbsp;</a></span>adi_uart_ConfigBaudRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_ConfigBaudRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t const&#160;</td>
          <td class="paramname"><em>nDivC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const&#160;</td>
          <td class="paramname"><em>nDivM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t const&#160;</td>
          <td class="paramname"><em>nDivN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const&#160;</td>
          <td class="paramname"><em>nOSR</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set baudrate by configuring the fractional dividors. </p>
<p>Baudrate is calculated as per below equation. </p><pre class="fragment">          Baudrate = (UARTCLK / (nDivM + nDivN/2048)*pow(2,nOSR+2)* nDivC)).
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDivC</td><td>Specify the "nDivC" in the above equation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDivM</td><td>Specify the "nDivM" in the above equation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nDivN</td><td>Specify the "nDivN" in the above equation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nOSR</td><td>Specify the "nOSR" " in the above equation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully set the baudrate for the device.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] Invalid UART device handle.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8f3f6a7234347e32da9ca6d930ac0ccc">ADI_UART_DEVICE_IN_USE</a> [D] Device is in use</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa083eb7765d831faf8044f38e277c32db">ADI_UART_INVALID_PARAMETER</a> [D] Input for baud rate values are out of range.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___driver.html#ga08aed3beb53ad9182191ccd00c80f5dd" title="Get the baudrate of the UART device instance. This is used in the scenario when a callback has not be...">adi_uart_GetBaudRate()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___driver.html#gab13134c91867cd224ef322df378f3197" title="Enable/Disable UART autobaud detection as well as configures the device for autobaud detection...">adi_uart_EnableAutobaud()</a>;</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It is expected that initialization of the power management driver is done before calling this function. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l01751">1751</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="adi__uart_8c_source.html#l02221">adi_uart_FlushTxChannel()</a>.</p>

</div>
</div>
<a id="gac56e4eb232ae7118a50e0e0338c9f204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac56e4eb232ae7118a50e0e0338c9f204">&#9670;&nbsp;</a></span>adi_uart_FlushTxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_FlushTxFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga7e3e8bd6d22a548d8ca2d9512a81eca2">ADI_UART_CONST_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To flush the TX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully flushed TX Fifo.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] The given UART handle is invalid. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l02108">2108</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="ga2a1c1c062f3a774661e67663ea68dd81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a1c1c062f3a774661e67663ea68dd81">&#9670;&nbsp;</a></span>adi_uart_FlushRxFifo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_FlushRxFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga7e3e8bd6d22a548d8ca2d9512a81eca2">ADI_UART_CONST_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the RX FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully flushed RX Fifo.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] The given UART handle is invalid. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l02138">2138</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="ga0c475b2b713da53f103fc5fc1c7085d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c475b2b713da53f103fc5fc1c7085d1">&#9670;&nbsp;</a></span>adi_uart_FlushRxChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_FlushRxChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga7e3e8bd6d22a548d8ca2d9512a81eca2">ADI_UART_CONST_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the Rx channel and disable interrupts. This will stop any buffers in flight and clear out any data that was in the RX holding register as well as the Rx fifo. Once this is done, in order to turn back on Rx interrupts, a new transaction will need to be started (<a class="el" href="group___u_a_r_t___driver.html#gaa9679689265db3e41ae60c8035f3ebb2" title="Submit the buffer for reading the data in ADI_UART_DATA_TRANSFER_MODE_BLOCKING. Call to this function...">adi_uart_Read()</a> or <a class="el" href="group___u_a_r_t___driver.html#ga46c5b11b70e27aa30f666f8b8b7636f1" title="Submit an empty buffer for receiving the data in ADI_UART_DATA_TRANSFER_MODE_NONBLOCKING. This will set up the Rx channel for notification on incoming data using either the DMA or UART interrupts, as well as mark the buffer as submitted. ">adi_uart_SubmitRxBuffer()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully flushed the Rx channel.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] The given UART handle is invalid. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l02170">2170</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="ga1f1af3e4d2a752a29d69a3dfd9d2eaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f1af3e4d2a752a29d69a3dfd9d2eaed">&#9670;&nbsp;</a></span>adi_uart_FlushTxChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_FlushTxChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga7e3e8bd6d22a548d8ca2d9512a81eca2">ADI_UART_CONST_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the Tx channel and disable interrupts.This will stop any buffers in flight and clear out any data that was in the TX holding register. Any data in the TX shift register will still finish transmitting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle to UART device obtained when an UART device is opened successfully.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully flushed the Tx channel.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] The given UART handle is invalid. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l02221">2221</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="ga801bf358ce3c3bd9cbd73a7ff208b35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga801bf358ce3c3bd9cbd73a7ff208b35b">&#9670;&nbsp;</a></span>adi_uart_IsTxComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_IsTxComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *const&#160;</td>
          <td class="paramname"><em>pbComplete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to let the API know if all the data had been drained from the Tx shift registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pbComplete</td><td>Pointer to a boolean variable. Contains "true" if there is no data left in the device to transmit and device can be disabled without data loss. Contains "false" if the data transmission is not complete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully retrieved the status of data transmission.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] Specified handle is invalid.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>adi_uart_getTxBuffer() or the callback may indicate that a transmit transaction is complete when the device is using the DMA. This is because the interrupt will trigger once the transmit holding register is empty. However, there may still be a some data in the shift register. If the transmit channel needs to be closed then the application must poll the transmit channel to see if all data has indeed been transmitted before shutting down the channel. Otherwise data will be lost. </dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l01596">1596</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
<a id="gad95e1ed77514e52dac3ef856e2fb8b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad95e1ed77514e52dac3ef856e2fb8b89">&#9670;&nbsp;</a></span>adi_uart_RegisterCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___driver.html#ga2e56dc2cd0ac9eadf2fb4f8f48d90e5f">ADI_UART_RESULT</a> adi_uart_RegisterCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___driver.html#ga13d69dc9cf05cd8e6f2983db6d7b99bf">ADI_UART_HANDLE</a> const&#160;</td>
          <td class="paramname"><em>hDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ADI_CALLBACK&#160;</td>
          <td class="paramname"><em>pfCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pCBParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registering a callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hDevice</td><td>Device handle obtained from <a class="el" href="group___u_a_r_t___driver.html#gaa0237738e853bd3e25835d7037ed5a58" title="Initialization function for the UART device. ">adi_uart_Open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pfCallback</td><td>Function pointer to callback. Passing a NULL pointer will unregister the callback function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pCBParam</td><td>Callback function parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status<ul>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5facefee8a9c10179eea1444f343e4fbd07">ADI_UART_SUCCESS</a> Successfully registered callback function.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fa8f3f6a7234347e32da9ca6d930ac0ccc">ADI_UART_DEVICE_IN_USE</a> [D] This operation is not allowed when a data transfer is in progress.</li>
<li><a class="el" href="group___u_a_r_t___driver.html#gga2e56dc2cd0ac9eadf2fb4f8f48d90e5fac285b5af4667d87c579660fa1dffeab0">ADI_UART_INVALID_HANDLE</a> [D] Invalid UART device handle. </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="adi__uart_8c_source.html#l01638">1638</a> of file <a class="el" href="adi__uart_8c_source.html">adi_uart.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Aug 6 2018 21:48:24 for ADuCM302x Device Drivers API Reference Manual by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
